<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helldivers Strategy - Defend Super Earth</title>
    <style>*{margin:0;padding:0;box-sizing:border-box;}body{background:radial-gradient(ellipse at 20% 80%,rgba(255,140,0,0.2) 0%,transparent 50%),radial-gradient(ellipse at 80% 20%,rgba(180,50,0,0.15) 0%,transparent 40%),radial-gradient(ellipse at 50% 10%,rgba(255,200,0,0.1) 0%,transparent 30%),linear-gradient(145deg,#2a1a0a 0%,#3a2010 20%,#4a2a15 40%,#3a1a0a 60%,#2a1505 80%,#1a0f00 100%);font-family:'Orbitron','Courier New',monospace;overflow:hidden;color:#FFD700;user-select:none;animation:planetaryAtmosphere 15s infinite ease-in-out;}@keyframes planetaryAtmosphere{0%,100%{filter:hue-rotate(0deg) brightness(1) contrast(1);}25%{filter:hue-rotate(5deg) brightness(1.05) contrast(1.1);}50%{filter:hue-rotate(-3deg) brightness(0.95) contrast(0.9);}75%{filter:hue-rotate(8deg) brightness(1.02) contrast(1.05);}}#gameContainer{position:relative;width:100vw;height:100vh;display:flex;}#gameCanvas{flex:1;cursor:crosshair;background:radial-gradient(ellipse at 25% 75%,rgba(200,80,20,0.4) 0%,transparent 35%),radial-gradient(ellipse at 75% 25%,rgba(150,60,10,0.3) 0%,transparent 30%),radial-gradient(ellipse at 10% 50%,rgba(255,120,0,0.2) 0%,transparent 25%),radial-gradient(ellipse at 90% 80%,rgba(180,90,30,0.25) 0%,transparent 40%),radial-gradient(circle at 30% 20%,rgba(255,255,0,0.08) 0%,transparent 60%),radial-gradient(circle at 70% 90%,rgba(255,150,0,0.06) 0%,transparent 50%),linear-gradient(125deg,#3a2010 0%,#4a1a0a 20%,#5a2515 40%,#4a2010 60%,#3a1505 80%,#2a0f00 100%);position:relative;overflow:hidden;}#gameCanvas::before{content:'';position:absolute;top:0;left:0;right:0;bottom:0;background:radial-gradient(circle at 20% 80%,rgba(255,170,0,0.1) 0%,transparent 30%),radial-gradient(circle at 80% 20%,rgba(0,170,255,0.08) 0%,transparent 25%);animation:atmosphereShift 8s infinite ease-in-out;pointer-events:none;}@keyframes atmosphereShift{0%,100%{opacity:0.7;transform:translateX(0) translateY(0) scale(1);}25%{opacity:0.9;transform:translateX(2%) translateY(-1%) scale(1.02);}50%{opacity:0.8;transform:translateX(-1%) translateY(2%) scale(0.98);}75%{opacity:1;transform:translateX(1%) translateY(1%) scale(1.01);}}#ui{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10;}#topBar{position:absolute;top:0;left:0;right:0;height:60px;background:linear-gradient(90deg,rgba(47,79,47,0.95) 0%,rgba(85,107,47,0.9) 30%,rgba(255,215,0,0.2) 50%,rgba(85,107,47,0.9) 70%,rgba(47,79,47,0.95) 100%);border-bottom:3px solid #FFD700;display:flex;align-items:center;padding:0 20px;box-shadow:0 3px 25px rgba(255,215,0,0.4);pointer-events:auto;}#missionInfo{flex:1;color:#FFD700;font-weight:bold;text-shadow:0 0 12px #FFD700,0 0 20px #FFA500;}#resources{display:flex;gap:20px;font-family:'Courier New',monospace;}.resource{display:flex;align-items:center;gap:5px;color:#FFA500;text-shadow:0 0 10px #FFA500,0 0 15px #FFD700;font-weight:bold;}#bottomPanel{position:absolute;bottom:0;left:0;right:0;height:120px;background:linear-gradient(0deg,rgba(0,20,40,0.95) 0%,rgba(0,40,80,0.95) 50%,rgba(0,20,40,0.7) 100%);border-top:2px solid #00ff88;display:flex;pointer-events:auto;box-shadow:0 -2px 20px rgba(0,255,136,0.3);}#stratagems{flex:1;padding:10px;display:flex;gap:10px;align-items:center;overflow-x:auto;}.stratagem{min-width:80px;height:80px;background:linear-gradient(135deg,#0a2040 0%,#1a4080 100%);border:2px solid #00aa66;border-radius:8px;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;transition:all 0.3s;color:#00ff88;font-size:12px;text-align:center;box-shadow:0 0 15px rgba(0,170,102,0.4);}.stratagem:hover{transform:scale(1.1);border-color:#00ff88;box-shadow:0 0 25px rgba(0,255,136,0.8);}.stratagem.selected{border-color:#ffaa00;box-shadow:0 0 25px rgba(255,170,0,0.8);}.stratagem.cooldown{opacity:0.5;cursor:not-allowed;}.stratagem .icon{font-size:24px;margin-bottom:5px;}.stratagem .name{font-size:10px;line-height:1.2;}.stratagem .cost{font-size:8px;color:#ffaa00;margin-top:2px;}#unitInfo{width:200px;padding:10px;border-left:2px solid #00aa66;color:#00ff88;}#missionSelect{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,20,40,0.95);border:3px solid #00ff88;border-radius:15px;padding:30px;text-align:center;color:#00ff88;box-shadow:0 0 50px rgba(0,255,136,0.5);z-index:100;pointer-events:auto;}.mission-option{display:block;width:100%;margin:10px 0;padding:15px;background:linear-gradient(135deg,#0a2040 0%,#1a4080 100%);border:2px solid #00aa66;border-radius:8px;color:#00ff88;cursor:pointer;transition:all 0.3s;text-align:left;pointer-events:auto;}.mission-option:hover{border-color:#00ff88;transform:scale(1.05);box-shadow:0 0 20px rgba(0,255,136,0.6);}#backButton{position:absolute;top:10px;right:10px;padding:10px 20px;background:linear-gradient(135deg,#ff4444 0%,#cc0000 100%);border:2px solid #ff6666;border-radius:8px;color:white;cursor:pointer;text-decoration:none;transition:all 0.3s;pointer-events:auto;font-family:'Orbitron',monospace;}#backButton:hover{transform:scale(1.1);box-shadow:0 0 15px rgba(255,68,68,0.8);}.fullscreen-btn{position:absolute;bottom:10px;right:10px;padding:10px;background:rgba(0,40,80,0.9);border:2px solid #00aa66;border-radius:8px;color:#00ff88;cursor:pointer;transition:all 0.3s;pointer-events:auto;}.fullscreen-btn:hover{border-color:#00ff88;box-shadow:0 0 15px rgba(0,255,136,0.6);}.explosion{position:absolute;pointer-events:none;width:100px;height:100px;border-radius:50%;background:radial-gradient(circle,#ffff00 0%,#ff6600 30%,#ff0000 70%,transparent 100%);animation:explode 0.5s ease-out forwards;}@keyframes explode{0%{transform:scale(0);opacity:1;}50%{transform:scale(1.5);opacity:0.8;}100%{transform:scale(3);opacity:0;}}.laser-beam{position:absolute;height:2px;background:linear-gradient(90deg,transparent 0%,#00ff88 50%,transparent 100%);box-shadow:0 0 10px #00ff88;animation:laser-pulse 0.1s ease-out;}@keyframes laser-pulse{0%{opacity:0;}50%{opacity:1;}100%{opacity:0;}}.particle{position:absolute;pointer-events:none;border-radius:50%;}.muzzle-flash{position:absolute;width:20px;height:20px;background:radial-gradient(circle,#ffff00 0%,#ff8800 50%,transparent 100%);border-radius:50%;animation:flash 0.1s ease-out forwards;pointer-events:none;}@keyframes flash{0%{transform:scale(0);opacity:1;}100%{transform:scale(2);opacity:0;}}@keyframes selectionPulse{0%{transform:scale(0.5);opacity:1;box-shadow:0 0 0 0 rgba(0,255,136,0.8);}50%{transform:scale(1.2);opacity:0.8;box-shadow:0 0 20px 10px rgba(0,255,136,0.4);}100%{transform:scale(1.5);opacity:0;box-shadow:0 0 30px 20px rgba(0,255,136,0);}}@keyframes moveOrderPulse{0%{transform:scale(0.3);opacity:1;box-shadow:0 0 0 0 rgba(255,170,0,0.8);}50%{transform:scale(1);opacity:0.6;box-shadow:0 0 15px 5px rgba(255,170,0,0.4);}100%{transform:scale(1.8);opacity:0;box-shadow:0 0 25px 15px rgba(255,170,0,0);}}@media (max-width:768px){#bottomPanel{height:100px;}.stratagem{min-width:60px;height:60px;}.stratagem .icon{font-size:18px;}.stratagem .name{font-size:8px;}#unitInfo{width:150px;}}</style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <div id="topBar">
                <div id="missionInfo">
                    <div>Mission: <span id="missionName">Defend Super Earth</span></div>
                    <div>Objective: <span id="currentObjective">Eliminate all hostiles</span></div>
                </div>
                <div id="resources">
                    <div class="resource">
                        <span>‚ö°</span>
                        <span id="requisition">100</span>
                    </div>
                    <div class="resource">
                        <span>üõ°Ô∏è</span>
                        <span id="reinforcements">5</span>
                    </div>
                    <div class="resource">
                        <span>‚è±Ô∏è</span>
                        <span id="missionTimer">05:00</span>
                    </div>
                </div>
            </div>

            <div id="bottomPanel">
                <div id="stratagems">
                    <div class="stratagem" data-stratagem="orbital-strike">
                        <div class="icon">üí•</div>
                        <div class="name">Orbital<br>Strike</div>
                        <div class="cost">50‚ö°</div>
                    </div>
                    <div class="stratagem" data-stratagem="reinforcements">
                        <div class="icon">üë•</div>
                        <div class="name">Reinforcements</div>
                        <div class="cost">30‚ö°</div>
                    </div>
                    <div class="stratagem" data-stratagem="supply-drop">
                        <div class="icon">üì¶</div>
                        <div class="name">Supply<br>Drop</div>
                        <div class="cost">25‚ö°</div>
                    </div>
                    <div class="stratagem" data-stratagem="smoke-barrage">
                        <div class="icon">üí®</div>
                        <div class="name">Smoke<br>Barrage</div>
                        <div class="cost">20‚ö°</div>
                    </div>
                    <div class="stratagem" data-stratagem="heavy-turret">
                        <div class="icon">üî´</div>
                        <div class="name">Heavy<br>Turret</div>
                        <div class="cost">75‚ö°</div>
                    </div>
                    <div class="stratagem" data-stratagem="laser-cannon">
                        <div class="icon">‚ö°</div>
                        <div class="name">Laser<br>Cannon</div>
                        <div class="cost">60‚ö°</div>
                    </div>
                </div>
                
                <div id="unitInfo">
                    <div style="font-weight: bold; margin-bottom: 10px;">Unit Status</div>
                    <div>Selected: <span id="selectedUnit">None</span></div>
                    <div>Health: <span id="unitHealth">-/-</span></div>
                    <div>Weapon: <span id="unitWeapon">-</span></div>
                </div>
            </div>

            <a href="../index.html" id="backButton">‚Üê Zur√ºck</a>
            <button id="fullscreenBtn" class="fullscreen-btn">‚õ∂</button>
        </div>

        <!-- Mission Selection Screen -->
        <div id="missionSelect">
            <h2 style="margin-bottom: 20px; color: #00ff88; text-shadow: 0 0 15px #00ff88;">
                Super Earth Command
            </h2>
            <p style="margin-bottom: 20px; color: #aaffcc;">
                Select your mission, Helldiver!
            </p>
            
            <div style="background: rgba(0, 40, 80, 0.8); padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #00aa66;">
                <h4 style="color: #00ff88; margin-bottom: 10px;">üéÆ CONTROLS:</h4>
                <div style="font-size: 12px; color: #cccccc; line-height: 1.4;">
                    ‚Ä¢ <strong>Click unit</strong> to select<br>
                    ‚Ä¢ <strong>Click ground</strong> to move<br>
                    ‚Ä¢ <strong>1-6 keys</strong> for stratagems<br>
                    ‚Ä¢ <strong>Tab</strong> to cycle units<br>
                    ‚Ä¢ <strong>Space</strong> to attack nearest enemy
                </div>
            </div>
            
            <button class="mission-option" data-mission="defend-base" onclick="startMissionDirect('defend-base')">
                <strong>üõ°Ô∏è Defend Base Alpha</strong><br>
                <small>Difficulty: ‚òÖ‚òÜ‚òÜ | Duration: 5min</small><br>
                <small>Hold the line against alien assault waves</small>
            </button>
            
            <button class="mission-option" data-mission="eliminate-nest" onclick="startMissionDirect('eliminate-nest')">
                <strong>üí• Destroy Hive Cluster</strong><br>
                <small>Difficulty: ‚òÖ‚òÖ‚òÜ | Duration: 7min</small><br>
                <small>Infiltrate and destroy alien breeding grounds</small>
            </button>
            
            <button class="mission-option" data-mission="escort-convoy" onclick="startMissionDirect('escort-convoy')">
                <strong>üöõ Escort Supply Convoy</strong><br>
                <small>Difficulty: ‚òÖ‚òÖ‚òÖ | Duration: 10min</small><br>
                <small>Protect vital supplies through hostile territory</small>
            </button>
            
            <button class="mission-option" onclick="debugGame()" style="background: linear-gradient(135deg, #ff4444 0%, #aa2222 100%); margin-top: 20px;">
                <strong>üîß DEBUG TEST</strong><br>
                <small>Test game functionality</small>
            </button>
        </div>
    </div>

    <script>const DEBUG = false;
const debug = {
log: DEBUG ? console.log.bind(console) : () => {},
warn: DEBUG ? console.warn.bind(console) : () => {},
error: DEBUG ? console.error.bind(console) : () => {},
info: DEBUG ? console.info.bind(console) : () => {}
};
if (!DEBUG) {
const noop = () => {};
console.log = noop;
console.warn = noop;
console.info = noop;
}
let canvas = null;
let ctx = null;
function initializeCanvas() {
console.log('üéØ Initializing canvas...');
canvas = document.getElementById('gameCanvas');
console.log('üñºÔ∏è Canvas found:', !!canvas);
if (!canvas) {
console.error('‚ùå Canvas element not found!');
return false;
}
ctx = canvas.getContext('2d');
console.log('‚úèÔ∏è Context created:', !!ctx);
if (!ctx) {
console.error('‚ùå Canvas context not available!');
return false;
}
console.log('‚úÖ Canvas successfully initialized');
return true;
}
let gameWidth, gameHeight;
let gameState = 'mission-select';
let selectedStratagem = null;
let selectedUnit = null;
let mouseX = 0, mouseY = 0;
let lastClickTime = 0;
const clickDebounceTime = 50; // 50ms between clicks
const DEBUG_CLICKS = false;
let units = [];
let enemies = [];
let projectiles = [];
let explosions = [];
let particles = [];
let buildings = [];
let requisition = 100;
let reinforcements = 5;
let missionTime = 300; // 5 minutes
let currentMission = null;
let currentWave = 0;
let waveTimer = 0;
function resizeCanvas() {
gameWidth = window.innerWidth;
gameHeight = window.innerHeight;
console.log('üìè Resizing canvas to:', gameWidth, 'x', gameHeight);
if (canvas) {
canvas.width = gameWidth;
canvas.height = gameHeight;
console.log('‚úÖ Canvas resized successfully');
if (ctx) {
ctx.clearRect(0, 0, gameWidth, gameHeight);
}
} else {
console.error('‚ùå Canvas not available for resizing');
}
}
function init() {
console.log('üéÆ === INITIALIZING GAME ===');
console.log('üìÑ DOM ready state:', document.readyState);
if (!initializeCanvas()) {
console.error('‚ùå CRITICAL ERROR: Canvas initialization failed!');
alert('Game initialization failed: Canvas not available');
return;
}
resizeCanvas();
setupEventListeners();
initAudio();
gameLoop();
if (DEBUG_CLICKS) {
console.log('=== INITIALIZATION COMPLETE ===');
console.log('Game state:', gameState);
console.log('Mission select element:', document.getElementById('missionSelect'));
const buttons = document.querySelectorAll('.mission-option');
console.log('Mission buttons found:', buttons.length);
buttons.forEach((btn, index) => {
console.log(`Button ${index}:`, {
element: btn,
dataset: btn.dataset.mission,
onclick: btn.onclick ? 'present' : 'missing',
visible: btn.offsetParent !== null,
clickable: getComputedStyle(btn).pointerEvents
});
});
console.log('Global functions available:');
console.log('- startMissionDirect:', typeof window.startMissionDirect);
console.log('- debugMissionClick:', typeof window.debugMissionClick);
}
}
function setupEventListeners() {
if (DEBUG_CLICKS) {
console.log('Setting up event listeners...');
}
window.addEventListener('resize', resizeCanvas);
if (canvas) {
console.log('üñ±Ô∏è Adding canvas event listeners...');
canvas.addEventListener('mousemove', handleMouseMove);
canvas.addEventListener('click', handleCanvasClick);
canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
canvas.addEventListener('contextmenu', (e) => e.preventDefault());
console.log('‚úÖ Canvas event listeners added successfully');
} else {
console.error('‚ùå Canvas not found, cannot add event listeners');
}
const stratagemButtons = document.querySelectorAll('.stratagem');
if (DEBUG_CLICKS) {
console.log('Found', stratagemButtons.length, 'stratagem buttons');
}
stratagemButtons.forEach(btn => {
btn.addEventListener('click', (e) => {
e.stopPropagation();
const stratagemType = e.currentTarget.dataset.stratagem;
if (stratagemType) {
if (DEBUG_CLICKS) {
console.log('Stratagem button clicked:', stratagemType);
}
selectStratagem(stratagemType);
}
});
});
const missionButtons = document.querySelectorAll('.mission-option');
console.log('üîò Found', missionButtons.length, 'mission buttons');
missionButtons.forEach((btn, i) => {
console.log(`üîò Button ${i}:`, btn.dataset.mission, 'onclick:', !!btn.onclick);
});
missionButtons.forEach((btn, index) => {
if (DEBUG_CLICKS) {
console.log(`Adding event listener to mission button ${index}:`, btn.dataset.mission);
}
btn.addEventListener('click', handleMissionButtonClick);
if (DEBUG_CLICKS) {
btn.addEventListener('mouseenter', () => {
console.log('Mission button hover:', btn.dataset.mission);
});
btn.addEventListener('mousedown', () => {
console.log('Mission button mousedown:', btn.dataset.mission);
});
}
});
const missionSelect = document.getElementById('missionSelect');
if (missionSelect) {
missionSelect.addEventListener('click', (e) => {
if (e.target.classList.contains('mission-option') || e.target.closest('.mission-option')) {
const button = e.target.classList.contains('mission-option') ? e.target : e.target.closest('.mission-option');
if (DEBUG_CLICKS) {
console.log('Mission button clicked via event delegation:', button.dataset.mission);
}
handleMissionButtonClick({ currentTarget: button, preventDefault: () => {}, stopPropagation: () => {} });
}
});
}
setTimeout(() => {
const buttons = document.querySelectorAll('.mission-option');
buttons.forEach(btn => {
if (!btn.onclick) { // Only if no onclick handler exists
btn.onclick = (e) => {
if (DEBUG_CLICKS) {
console.log('Mission button clicked via onclick:', btn.dataset.mission);
}
handleMissionButtonClick(e);
};
}
});
}, 100);
const fullscreenBtn = document.getElementById('fullscreenBtn');
if (fullscreenBtn) {
fullscreenBtn.addEventListener('click', toggleFullscreen);
}
document.addEventListener('keydown', handleKeyDown);
if (DEBUG_CLICKS) {
console.log('Event listeners setup complete');
}
}
function handleMouseMove(e) {
mouseX = e.clientX;
mouseY = e.clientY;
}
let touchStartTime = 0;
let touchStartPos = { x: 0, y: 0 };
function handleTouchStart(e) {
e.preventDefault();
e.stopPropagation();
touchStartTime = Date.now();
const touch = e.touches[0];
const rect = canvas.getBoundingClientRect();
const scaleX = gameWidth / rect.width;
const scaleY = gameHeight / rect.height;
touchStartPos.x = (touch.clientX - rect.left) * scaleX;
touchStartPos.y = (touch.clientY - rect.top) * scaleY;
}
function handleTouchEnd(e) {
e.preventDefault();
e.stopPropagation();
if (DEBUG_CLICKS) {
console.log('Touch end event');
}
if (gameState !== 'playing') return;
if (!canvas) return;
const touchDuration = Date.now() - touchStartTime;
const touch = e.changedTouches[0];
if (!touch) return;
const rect = canvas.getBoundingClientRect();
if (rect.width <= 0 || rect.height <= 0) return;
const scaleX = gameWidth / rect.width;
const scaleY = gameHeight / rect.height;
const touchEndX = (touch.clientX - rect.left) * scaleX;
const touchEndY = (touch.clientY - rect.top) * scaleY;
const distance = Math.sqrt(
(touchEndX - touchStartPos.x) ** 2 +
(touchEndY - touchStartPos.y) ** 2
);
if (DEBUG_CLICKS) {
console.log('Touch: duration =', touchDuration, 'distance =', Math.round(distance));
}
if (touchDuration < 800 && distance < 40) { // More forgiving for touch
const fakeEvent = {
clientX: touch.clientX,
clientY: touch.clientY,
preventDefault: () => {},
stopPropagation: () => {},
type: 'click'
};
if (DEBUG_CLICKS) {
console.log('Touch converted to click');
}
handleCanvasClick(fakeEvent);
}
}
function handleTouchMove(e) {
e.preventDefault();
const touch = e.touches[0];
mouseX = touch.clientX;
mouseY = touch.clientY;
}
function handleMissionButtonClick(e) {
if (DEBUG_CLICKS) {
console.log('=== MISSION BUTTON CLICKED ===');
console.log('Button:', e.currentTarget);
console.log('Mission type:', e.currentTarget.dataset.mission);
console.log('Event:', e);
console.log('Current game state:', gameState);
}
if (e.preventDefault) e.preventDefault();
if (e.stopPropagation) e.stopPropagation();
const missionType = e.currentTarget.dataset.mission;
if (missionType) {
if (DEBUG_CLICKS) {
console.log('Calling startMission with:', missionType);
}
startMission(missionType);
} else {
console.error('Mission type not found on button:', e.currentTarget);
}
}
window.startMissionDirect = function(missionType) {
console.log('üéÆ === MISSION STARTED VIA DIRECT CALL ===');
console.log('üéØ Mission type:', missionType);
console.log('üìä Current game state before:', gameState);
if (missionType) {
startMission(missionType);
} else {
console.error('‚ùå No mission type provided to startMissionDirect');
}
};
window.debugMissionClick = function(missionType) {
console.log('Debug mission click called with:', missionType);
console.log('Current game state:', gameState);
console.log('Canvas element:', canvas);
console.log('Mission select element:', document.getElementById('missionSelect'));
startMissionDirect(missionType);
};
window.debugGame = function() {
console.log('üîß === DEBUG TEST STARTED ===');
console.log('üéÆ Current game state:', gameState);
console.log('üñºÔ∏è Canvas element:', canvas);
console.log('‚úèÔ∏è Canvas context:', ctx);
console.log('üìè Game dimensions:', gameWidth, 'x', gameHeight);
console.log('üî´ Current units:', units.length);
console.log('üöÄ Starting defend-base mission for test...');
startMission('defend-base');
setTimeout(() => {
console.log('üìä After mission start:');
console.log('üéØ Game state:', gameState);
console.log('üî´ Units count:', units.length);
console.log('üè¢ Buildings count:', buildings.length);
if (units.length > 0) {
console.log('‚úÖ Units successfully created!');
console.log('üéØ Selecting first unit for test...');
selectedUnit = units[0];
updateUI();
} else {
console.error('‚ùå No units were created!');
}
}, 100);
};
function selectStratagem(type) {
const costs = {
'orbital-strike': 50,
'reinforcements': 30,
'supply-drop': 25,
'smoke-barrage': 20,
'heavy-turret': 75,
'laser-cannon': 60
};
if (requisition < costs[type]) {
const stratagemButton = document.querySelector(`[data-stratagem="${type}"]`);
if (stratagemButton) {
stratagemButton.style.borderColor = '#ff0000';
stratagemButton.style.boxShadow = '0 0 15px rgba(255, 0, 0, 0.8)';
setTimeout(() => {
stratagemButton.style.borderColor = '#00aa66';
stratagemButton.style.boxShadow = '0 0 15px rgba(0, 170, 102, 0.4)';
}, 500);
}
return;
}
document.querySelectorAll('.stratagem').forEach(s => s.classList.remove('selected'));
if (selectedStratagem === type) {
selectedStratagem = null;
canvas.style.cursor = 'crosshair';
return;
}
selectedStratagem = type;
const stratagemElement = document.querySelector(`[data-stratagem="${type}"]`);
if (stratagemElement) {
stratagemElement.classList.add('selected');
}
canvas.style.cursor = 'crosshair';
}
function handleCanvasClick(e) {
console.log('üñ±Ô∏è Canvas click detected, gameState:', gameState);
if (gameState !== 'playing') {
console.log('‚ùå Click ignored - game not playing (current state:', gameState, ')');
return;
}
if (!canvas || !ctx) {
console.error('Canvas or context not available for click handling');
return;
}
const now = Date.now();
if (now - lastClickTime < clickDebounceTime) {
if (DEBUG_CLICKS) {
console.log('Click debounced');
}
return;
}
lastClickTime = now;
e.preventDefault();
e.stopPropagation();
const rect = canvas.getBoundingClientRect();
let clickX, clickY;
if (rect.width > 0 && rect.height > 0) {
const scaleX = gameWidth / rect.width;
const scaleY = gameHeight / rect.height;
clickX = (e.clientX - rect.left) * scaleX;
clickY = (e.clientY - rect.top) * scaleY;
} else {
clickX = e.clientX - rect.left;
clickY = e.clientY - rect.top;
}
clickX = Math.max(0, Math.min(gameWidth, clickX));
clickY = Math.max(0, Math.min(gameHeight, clickY));
if (DEBUG_CLICKS) {
console.log(`Click at (${Math.round(clickX)}, ${Math.round(clickY)})`);
console.log('Canvas rect:', rect);
console.log('Game dimensions:', gameWidth, 'x', gameHeight);
}
if (selectedStratagem) {
if (DEBUG_CLICKS) {
console.log('Using stratagem:', selectedStratagem);
}
if (!audioCtx) {
initAudio();
}
useStratagem(selectedStratagem, clickX, clickY);
selectedStratagem = null;
document.querySelectorAll('.stratagem').forEach(s => s.classList.remove('selected'));
if (canvas) canvas.style.cursor = 'crosshair';
} else {
if (DEBUG_CLICKS) {
console.log('Attempting unit selection/movement');
}
const result = selectUnitAt(clickX, clickY);
if (DEBUG_CLICKS) {
console.log('Selection result:', result);
}
}
}
function useStratagem(type, x, y) {
const costs = {
'orbital-strike': 50,
'reinforcements': 30,
'supply-drop': 25,
'smoke-barrage': 20,
'heavy-turret': 75,
'laser-cannon': 60
};
if (requisition < costs[type]) {
return; // Not enough resources
}
requisition -= costs[type];
updateUI();
switch(type) {
case 'orbital-strike':
createOrbitalStrike(x, y);
break;
case 'reinforcements':
deployReinforcements(x, y);
break;
case 'supply-drop':
createSupplyDrop(x, y);
break;
case 'smoke-barrage':
createSmokeBarrage(x, y);
break;
case 'heavy-turret':
deployTurret(x, y);
break;
case 'laser-cannon':
deployLaserCannon(x, y);
break;
}
}
function selectUnitAt(x, y) {
console.log(`üéØ selectUnitAt called with (${Math.round(x)}, ${Math.round(y)})`);
console.log('üî´ Units array length:', units ? units.length : 'null');
console.log('üéÆ Current game state:', gameState);
if (!units || units.length === 0) {
if (DEBUG_CLICKS) {
console.log('No units available for selection');
}
return false;
}
let closestUnit = null;
let closestDistance = Infinity;
for (let i = 0; i < units.length; i++) {
const unit = units[i];
if (!unit) {
if (DEBUG_CLICKS) {
console.log(`Unit at index ${i} is null/undefined`);
}
continue;
}
if (typeof unit.x !== 'number' || typeof unit.y !== 'number') {
if (DEBUG_CLICKS) {
console.log(`Unit at index ${i} has invalid coordinates:`, unit.x, unit.y);
}
continue;
}
const dist = Math.sqrt((unit.x - x) ** 2 + (unit.y - y) ** 2);
const selectionRadius = Math.max(35, (unit.size || 15) + 25);
if (DEBUG_CLICKS) {
console.log(`Unit ${i}: pos(${Math.round(unit.x)}, ${Math.round(unit.y)}), dist: ${Math.round(dist)}, radius: ${selectionRadius}`);
}
if (dist < selectionRadius && dist < closestDistance) {
closestUnit = unit;
closestDistance = dist;
}
}
if (closestUnit) {
console.log('‚úÖ Unit selected:', closestUnit.type || 'unknown', 'at distance', Math.round(closestDistance));
console.log('üìç Unit position:', Math.round(closestUnit.x), Math.round(closestUnit.y));
selectedUnit = closestUnit;
updateUI();
try {
createSelectionEffect(closestUnit.x, closestUnit.y);
} catch (e) {
console.error('Error creating selection effect:', e);
}
return true; // Unit was selected
}
if (selectedUnit && selectedUnit.x !== undefined && selectedUnit.y !== undefined) {
console.log('üö∂ Moving selected unit to:', Math.round(x), Math.round(y));
console.log('üîÑ Previous position:', Math.round(selectedUnit.x), Math.round(selectedUnit.y));
console.log('üéØ Setting targetX/Y:', Math.round(x), Math.round(y));
selectedUnit.targetX = x;
selectedUnit.targetY = y;
try {
createMoveOrderEffect(x, y);
console.log('‚úÖ Movement command successful!');
} catch (e) {
console.error('Error creating move order effect:', e);
}
return true; // Movement command given
}
if (DEBUG_CLICKS) {
console.log('No unit selected and no unit to move');
}
return false; // No action taken
}
function startMission(type) {
console.log('üöÄ === STARTING MISSION ===');
console.log('üéØ Mission type:', type);
console.log('üìä Previous game state:', gameState);
console.log('üñºÔ∏è Canvas dimensions:', gameWidth, 'x', gameHeight);
try {
currentMission = {
type: type,
objectives: [],
enemySpawns: []
};
units = [];
enemies = [];
projectiles = [];
particles = [];
buildings = [];
selectedUnit = null;
selectedStratagem = null;
requisition = 100;
reinforcements = 5;
missionTime = 300;
currentWave = 0;
waveTimer = 0;
if (DEBUG_CLICKS) {
console.log('Game arrays reset, setting state to playing...');
}
gameState = 'playing';
const missionSelect = document.getElementById('missionSelect');
if (missionSelect) {
missionSelect.style.display = 'none';
if (DEBUG_CLICKS) {
console.log('Mission select panel hidden');
}
} else {
console.error('Mission select panel not found!');
}
if (DEBUG_CLICKS) {
console.log('Game state set to playing, initializing mission...');
console.log('Current game state:', gameState);
}
switch(type) {
case 'defend-base':
if (DEBUG_CLICKS) console.log('Setting up defend base mission...');
setupDefendBaseMission();
break;
case 'eliminate-nest':
if (DEBUG_CLICKS) console.log('Setting up eliminate nest mission...');
setupEliminateNestMission();
break;
case 'escort-convoy':
if (DEBUG_CLICKS) console.log('Setting up escort convoy mission...');
setupEscortMission();
break;
default:
console.error('Unknown mission type:', type);
return;
}
console.log('üéÆ Mission setup complete!');
console.log('üî´ Units created:', units.length);
console.log('üè¢ Buildings created:', buildings.length);
console.log('üéØ Final game state:', gameState);
if (units.length > 0) {
console.log('üìç Unit positions:', units.map(u => ({
type: u.type,
x: Math.round(u.x),
y: Math.round(u.y),
size: u.size
})));
}
updateUI();
if (DEBUG_CLICKS) {
console.log('=== MISSION START COMPLETE ===');
}
} catch (error) {
console.error('Error starting mission:', error);
console.error('Stack trace:', error.stack);
}
}
class Unit {
constructor(x, y, type) {
this.x = x;
this.y = y;
this.type = type;
this.targetX = x;
this.targetY = y;
this.health = 100;
this.maxHealth = 100;
this.size = 15;
this.speed = 1;
this.weapon = this.getWeaponForType(type);
this.lastShotTime = 0;
this.angle = 0;
}
getWeaponForType(type) {
const weapons = {
'marine': { damage: 20, range: 100, fireRate: 300 },
'heavy': { damage: 40, range: 120, fireRate: 500 },
'convoy': { damage: 0, range: 0, fireRate: 0 }
};
return weapons[type] || weapons.marine;
}
update() {
const dx = this.targetX - this.x;
const dy = this.targetY - this.y;
const dist = Math.sqrt(dx * dx + dy * dy);
if (selectedUnit === this && dist > 5) {
console.log(`üèÉ ${this.type} moving: dist=${Math.round(dist)}, speed=${this.speed}`);
console.log(`üìç Current: (${Math.round(this.x)}, ${Math.round(this.y)}) ‚Üí Target: (${Math.round(this.targetX)}, ${Math.round(this.targetY)})`);
}
if (dist > 5) {
const newX = this.x + (dx / dist) * this.speed;
const newY = this.y + (dy / dist) * this.speed;
this.x = newX;
this.y = newY;
this.angle = Math.atan2(dy, dx);
if (selectedUnit === this) {
console.log(`‚û°Ô∏è New position: (${Math.round(this.x)}, ${Math.round(this.y)})`);
}
}
this.findAndAttackEnemies();
}
findAndAttackEnemies() {
if (this.weapon.damage === 0) return;
const now = Date.now();
if (now - this.lastShotTime < this.weapon.fireRate) return;
let nearestEnemy = null;
let nearestDist = this.weapon.range;
for (let enemy of enemies) {
const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
if (dist < nearestDist) {
nearestEnemy = enemy;
nearestDist = dist;
}
}
if (nearestEnemy) {
this.shootAt(nearestEnemy);
this.lastShotTime = now;
}
}
shootAt(target) {
const angle = Math.atan2(target.y - this.y, target.x - this.x);
const muzzleX = this.x + Math.cos(angle) * this.size;
const muzzleY = this.y + Math.sin(angle) * this.size;
createMuzzleFlash(muzzleX, muzzleY, angle);
playShootSound();
projectiles.push(new Projectile(
muzzleX,
muzzleY,
angle,
this.weapon.damage,
'friendly'
));
}
draw() {
ctx.save();
ctx.translate(this.x, this.y);
ctx.rotate(this.angle);
const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
if (this.type === 'convoy') {
gradient.addColorStop(0, '#888888');
gradient.addColorStop(1, '#444444');
ctx.fillStyle = gradient;
ctx.fillRect(-20, -10, 40, 20);
ctx.strokeStyle = '#00ff88';
ctx.lineWidth = 2;
ctx.strokeRect(-20, -10, 40, 20);
} else {
ctx.fillStyle = '#002244';
ctx.beginPath();
ctx.ellipse(-this.size * 0.4, this.size * 0.2, this.size * 0.7, this.size * 1.3, 0, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = '#ffdd00';
ctx.beginPath();
ctx.arc(-this.size * 0.4, 0, 4, 0, Math.PI * 2);
ctx.fill();
gradient.addColorStop(0, '#FFD700');  /* Gold core */
gradient.addColorStop(0.2, '#FFA500'); /* Orange */
gradient.addColorStop(0.4, '#DAA520'); /* Goldenrod */
gradient.addColorStop(0.6, '#8FBC8F'); /* Military green */
gradient.addColorStop(0.8, '#556B2F'); /* Olive drab */
gradient.addColorStop(1, '#2F4F2F');   /* Dark military green */
ctx.fillStyle = gradient;
ctx.beginPath();
ctx.arc(0, 0, this.size, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 15;
ctx.shadowColor = '#FFD700'; /* Helldivers gold */
ctx.fill();
ctx.shadowBlur = 0;
ctx.strokeStyle = '#B8860B'; /* Dark goldenrod */
ctx.lineWidth = 2;
for (let i = 0; i < 6; i++) {
const angle = (i / 6) * Math.PI * 2;
const x1 = Math.cos(angle) * this.size * 0.6;
const y1 = Math.sin(angle) * this.size * 0.6;
const x2 = Math.cos(angle) * this.size * 0.9;
const y2 = Math.sin(angle) * this.size * 0.9;
ctx.beginPath();
ctx.moveTo(x1, y1);
ctx.lineTo(x2, y2);
ctx.stroke();
}
ctx.fillStyle = '#0088bb';
ctx.beginPath();
ctx.arc(0, -this.size * 0.3, this.size * 0.6, 0, Math.PI);
ctx.fill();
ctx.fillStyle = '#44bbff';
ctx.beginPath();
ctx.arc(0, -this.size * 0.3, this.size * 0.4, 0, Math.PI);
ctx.fill();
ctx.fillStyle = '#ffffff';
ctx.beginPath();
ctx.arc(-this.size * 0.15, -this.size * 0.35, 2, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = '#666666';
ctx.fillRect(-this.size * 0.8, -this.size * 0.2, this.size * 0.4, this.size * 0.6);
ctx.fillStyle = '#ffaa00';
ctx.beginPath();
ctx.arc(-this.size * 0.9, -this.size * 0.1, 1.5, 0, Math.PI * 2);
ctx.fill();
ctx.beginPath();
ctx.arc(-this.size * 0.9, this.size * 0.1, 1.5, 0, Math.PI * 2);
ctx.fill();
if (Math.abs(this.targetX - this.x) > 5 || Math.abs(this.targetY - this.y) > 5) {
for (let i = 0; i < 4; i++) {
const thrustX = -this.size - 5 - Math.random() * 10;
const thrustY = (Math.random() - 0.5) * this.size * 0.6;
ctx.fillStyle = `rgba(0, 150, 255, ${0.9 - i * 0.15})`;
ctx.beginPath();
ctx.arc(thrustX, thrustY, 2, 0, Math.PI * 2);
ctx.fill();
}
}
ctx.fillStyle = '#2F4F2F'; /* Dark military green */
ctx.fillRect(this.size * 0.2, -4, this.size + 20, 8);
ctx.fillStyle = '#556B2F'; /* Olive drab */
ctx.fillRect(this.size * 0.3, -3, this.size + 15, 6);
ctx.fillStyle = '#1C1C1C'; /* Dark gray */
for (let i = 0; i < 6; i++) {
ctx.fillRect(this.size * 0.4 + i * 4, -2, 1, 4);
}
ctx.fillStyle = '#1C1C1C';
ctx.fillRect(this.size * 0.6, -7, 12, 4);
ctx.fillStyle = '#4169E1'; /* Royal blue lens */
ctx.beginPath();
ctx.arc(this.size * 0.66, -5, 1.5, 0, Math.PI * 2);
ctx.fill();
ctx.strokeStyle = '#696969'; /* Dim gray */
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(this.size * 0.3, -4.5);
ctx.lineTo(this.size + 12, -4.5);
ctx.moveTo(this.size * 0.3, 4.5);
ctx.lineTo(this.size + 12, 4.5);
ctx.stroke();
ctx.fillStyle = '#1C1C1C';
ctx.fillRect(this.size + 15, -3, 6, 6);
for (let i = 0; i < 4; i++) {
const angle = (i / 4) * Math.PI * 2;
const portX = (this.size + 18) + Math.cos(angle) * 2;
const portY = Math.sin(angle) * 2;
ctx.fillStyle = '#FFD700';
ctx.beginPath();
ctx.arc(portX, portY, 0.8, 0, Math.PI * 2);
ctx.fill();
}
if (Date.now() - this.lastShotTime < 100) {
ctx.fillStyle = `rgba(255, 215, 0, ${1 - (Date.now() - this.lastShotTime) / 100})`;
ctx.beginPath();
ctx.arc(this.size + 21, 0, 8, 0, Math.PI * 2);
ctx.fill();
for (let i = 0; i < 6; i++) {
const angle = (i / 6) * Math.PI * 2;
const flashX = (this.size + 25) + Math.cos(angle) * 12;
const flashY = Math.sin(angle) * 12;
ctx.fillStyle = `rgba(255, 165, 0, ${0.8 - (Date.now() - this.lastShotTime) / 125})`;
ctx.beginPath();
ctx.arc(flashX, flashY, 2, 0, Math.PI * 2);
ctx.fill();
}
}
ctx.fillStyle = '#32CD32'; /* Lime green - ready status */
ctx.fillRect(this.size * 0.5, -1, 3, 2);
ctx.fillStyle = '#ffdd00';
ctx.font = 'bold 8px Arial';
ctx.textAlign = 'center';
ctx.strokeStyle = '#000000';
ctx.lineWidth = 1;
const rankSymbol = this.type === 'marine' ? 'üöÄ' : this.type === 'heavy' ? '‚ö°' : 'üéØ';
ctx.strokeText(rankSymbol, 0, this.size * 0.3);
ctx.fillText(rankSymbol, 0, this.size * 0.3);
}
ctx.restore();
if (this.health < this.maxHealth) {
const barWidth = this.size * 2.5;
const barHeight = 6;
ctx.fillStyle = '#440000';
ctx.fillRect(this.x - barWidth/2, this.y - this.size - 15, barWidth, barHeight);
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 1;
ctx.strokeRect(this.x - barWidth/2, this.y - this.size - 15, barWidth, barHeight);
const healthPercent = this.health / this.maxHealth;
const healthColor = healthPercent > 0.6 ? '#00ff00' : healthPercent > 0.3 ? '#ffaa00' : '#ff0000';
ctx.fillStyle = healthColor;
ctx.fillRect(this.x - barWidth/2 + 1, this.y - this.size - 14,
(barWidth - 2) * healthPercent, barHeight - 2);
}
if (selectedUnit === this) {
ctx.strokeStyle = '#ffaa00';
ctx.lineWidth = 3;
ctx.shadowBlur = 8;
ctx.shadowColor = '#ffaa00';
ctx.beginPath();
ctx.arc(this.x, this.y, this.size + 8, 0, Math.PI * 2);
ctx.stroke();
ctx.shadowBlur = 0;
const pulseRadius = this.size + 12 + Math.sin(Date.now() * 0.008) * 4;
ctx.strokeStyle = 'rgba(255, 170, 0, 0.5)';
ctx.lineWidth = 2;
ctx.beginPath();
ctx.arc(this.x, this.y, pulseRadius, 0, Math.PI * 2);
ctx.stroke();
}
ctx.fillStyle = '#ffffff';
ctx.font = 'bold 10px Arial';
ctx.textAlign = 'center';
ctx.strokeStyle = '#000000';
ctx.lineWidth = 3;
ctx.strokeText(this.type.toUpperCase(), this.x, this.y + this.size + 25);
ctx.fillText(this.type.toUpperCase(), this.x, this.y + this.size + 25);
}
}
class Enemy {
constructor(x, y, type = 'basic') {
this.x = x;
this.y = y;
this.type = type;
this.targetUnit = null;
this.lastAttackTime = 0;
this.spawnTime = Date.now();
this.setupStats(type);
}
setupStats(type) {
switch(type) {
case 'basic':
this.health = 50;
this.maxHealth = 50;
this.size = 12;
this.speed = 0.8;
this.damage = 12;
this.attackRange = 20;
this.color = '#ff4444';
break;
case 'fast':
this.health = 30;
this.maxHealth = 30;
this.size = 10;
this.speed = 1.5;
this.damage = 8;
this.attackRange = 15;
this.color = '#ff6644';
break;
case 'heavy':
this.health = 120;
this.maxHealth = 120;
this.size = 18;
this.speed = 0.4;
this.damage = 25;
this.attackRange = 25;
this.color = '#aa2222';
this.armor = 3;
break;
case 'spitter':
this.health = 40;
this.maxHealth = 40;
this.size = 14;
this.speed = 0.3;
this.damage = 15;
this.attackRange = 80;
this.color = '#44aa44';
this.rangedAttack = true;
break;
case 'exploder':
this.health = 25;
this.maxHealth = 25;
this.size = 8;
this.speed = 1.2;
this.damage = 50;
this.attackRange = 30;
this.color = '#ffaa44';
this.explosive = true;
break;
}
}
update() {
let nearestTarget = null;
let nearestDist = Infinity;
for (let unit of units) {
const dist = Math.sqrt((unit.x - this.x) ** 2 + (unit.y - this.y) ** 2);
if (dist < nearestDist) {
nearestTarget = unit;
nearestDist = dist;
}
}
if (this.type === 'basic' || this.type === 'heavy') {
for (let building of buildings) {
const dist = Math.sqrt((building.x - this.x) ** 2 + (building.y - this.y) ** 2);
if (dist < nearestDist) {
nearestTarget = building;
nearestDist = dist;
}
}
}
if (nearestTarget) {
this.targetUnit = nearestTarget;
this.updateMovement(nearestTarget, nearestDist);
this.updateAttack(nearestTarget, nearestDist);
}
this.updateSpecialBehavior();
}
updateMovement(target, dist) {
const dx = target.x - this.x;
const dy = target.y - this.y;
if (dist > this.attackRange) {
this.x += (dx / dist) * this.speed;
this.y += (dy / dist) * this.speed;
if (this.type === 'basic' && Math.random() < 0.02) {
this.x += (Math.random() - 0.5) * 10;
this.y += (Math.random() - 0.5) * 10;
}
}
}
updateAttack(target, dist) {
if (dist <= this.attackRange) {
const now = Date.now();
let attackCooldown = 1000;
if (this.type === 'fast') attackCooldown = 800;
else if (this.type === 'heavy') attackCooldown = 1500;
else if (this.type === 'spitter') attackCooldown = 2000;
else if (this.type === 'exploder') attackCooldown = 100;
if (now - this.lastAttackTime > attackCooldown) {
this.attack(target);
this.lastAttackTime = now;
}
}
}
attack(target) {
if (this.type === 'exploder') {
this.explode();
return;
} else if (this.type === 'spitter') {
this.spitAttack(target);
} else {
target.health -= Math.max(1, this.damage - (target.armor || 0));
createMuzzleFlash(this.x, this.y);
createImpactEffect(target.x, target.y, 'organic');
}
}
spitAttack(target) {
const angle = Math.atan2(target.y - this.y, target.x - this.x);
projectiles.push(new AcidProjectile(this.x, this.y, angle, this.damage));
createMuzzleFlash(this.x, this.y, angle);
}
explode() {
createExplosion(this.x, this.y, 'medium');
for (let unit of units) {
const dist = Math.sqrt((unit.x - this.x) ** 2 + (unit.y - this.y) ** 2);
if (dist < 60) {
const damage = Math.max(5, this.damage - dist);
unit.health -= damage;
}
}
const index = enemies.indexOf(this);
if (index > -1) {
enemies.splice(index, 1);
}
}
updateSpecialBehavior() {
if (this.type === 'fast' && Math.random() < 0.03) {
const angle = Math.random() * Math.PI * 2;
this.x += Math.cos(angle) * 15;
this.y += Math.sin(angle) * 15;
}
if (this.type === 'exploder' && this.targetUnit) {
const dist = Math.sqrt((this.targetUnit.x - this.x) ** 2 + (this.targetUnit.y - this.y) ** 2);
if (dist < 100) {
this.speed = 2.0; // Speed boost when close
if (Math.random() < 0.5) {
particles.push(new Particle(this.x, this.y, 'energy', {
life: 20,
size: 4,
color: this.color
}));
}
}
}
}
takeDamage(damage) {
this.health -= Math.max(1, damage - (this.armor || 0));
return this.health <= 0;
}
draw() {
ctx.save();
const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
gradient.addColorStop(0, '#ff6666');
gradient.addColorStop(0.4, '#ff3333');
gradient.addColorStop(0.7, '#cc2222');
gradient.addColorStop(1, '#881111');
ctx.fillStyle = gradient;
ctx.beginPath();
ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 12;
ctx.shadowColor = '#ff4444';
ctx.fill();
ctx.shadowBlur = 0;
ctx.strokeStyle = '#cccccc';
ctx.lineWidth = 2;
ctx.beginPath();
ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
ctx.stroke();
ctx.strokeStyle = '#888888';
ctx.lineWidth = 1;
for (let i = 0; i < 8; i++) {
const angle = (i / 8) * Math.PI * 2;
const x1 = this.x + Math.cos(angle) * this.size * 0.7;
const y1 = this.y + Math.sin(angle) * this.size * 0.7;
const x2 = this.x + Math.cos(angle) * this.size * 0.9;
const y2 = this.y + Math.sin(angle) * this.size * 0.9;
ctx.beginPath();
ctx.moveTo(x1, y1);
ctx.lineTo(x2, y2);
ctx.stroke();
}
const scanPulse = 0.7 + Math.sin(Date.now() * 0.01) * 0.3;
ctx.fillStyle = `rgba(255, 0, 0, ${scanPulse})`;
ctx.beginPath();
ctx.arc(this.x, this.y - this.size * 0.3, 3, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 6;
ctx.shadowColor = '#ff0000';
ctx.fill();
ctx.shadowBlur = 0;
if (this.type === 'heavy') {
ctx.fillStyle = '#444444';
ctx.fillRect(this.x - this.size + 2, this.y - this.size/2, this.size * 2 - 4, this.size);
ctx.fillStyle = '#666666';
for (let i = 0; i < 12; i++) {
const angle = (i / 12) * Math.PI * 2;
const x = this.x + Math.cos(angle) * (this.size - 3);
const y = this.y + Math.sin(angle) * (this.size - 3);
ctx.beginPath();
ctx.arc(x, y, 1, 0, Math.PI * 2);
ctx.fill();
}
ctx.strokeStyle = '#333333';
ctx.lineWidth = 4;
ctx.beginPath();
ctx.moveTo(this.x + this.size, this.y - 4);
ctx.lineTo(this.x + this.size + 12, this.y - 4);
ctx.moveTo(this.x + this.size, this.y + 4);
ctx.lineTo(this.x + this.size + 12, this.y + 4);
ctx.stroke();
} else if (this.type === 'fast') {
for (let i = 0; i < 8; i++) {
const trailAngle = Date.now() * 0.02 + (i / 8) * Math.PI * 2;
const x = this.x + Math.cos(trailAngle) * (this.size + 5 + i * 2);
const y = this.y + Math.sin(trailAngle) * (this.size + 5 + i * 2);
ctx.fillStyle = `rgba(255, 100, 100, ${0.8 - i * 0.1})`;
ctx.beginPath();
ctx.arc(x, y, 1, 0, Math.PI * 2);
ctx.fill();
}
ctx.fillStyle = '#ffaaaa';
ctx.beginPath();
ctx.arc(this.x, this.y, this.size * 0.6, 0, Math.PI * 2);
ctx.fill();
for (let i = 0; i < 4; i++) {
const spikeAngle = Date.now() * 0.01 + (i / 4) * Math.PI * 2;
const x1 = this.x + Math.cos(spikeAngle) * this.size * 0.8;
const y1 = this.y + Math.sin(spikeAngle) * this.size * 0.8;
const x2 = this.x + Math.cos(spikeAngle) * this.size * 1.2;
const y2 = this.y + Math.sin(spikeAngle) * this.size * 1.2;
ctx.strokeStyle = '#ff6666';
ctx.lineWidth = 2;
ctx.beginPath();
ctx.moveTo(x1, y1);
ctx.lineTo(x2, y2);
ctx.stroke();
}
} else if (this.type === 'spitter') {
ctx.fillStyle = '#22aa22';
ctx.beginPath();
ctx.arc(this.x, this.y - this.size/2, 8, 0, Math.PI * 2);
ctx.fill();
ctx.strokeStyle = '#44cc44';
ctx.lineWidth = 3;
for (let i = 0; i < 3; i++) {
const tubeAngle = (i / 3) * Math.PI * 2;
const x1 = this.x + Math.cos(tubeAngle) * this.size * 0.5;
const y1 = this.y + Math.sin(tubeAngle) * this.size * 0.5;
const x2 = this.x + Math.cos(tubeAngle) * this.size;
const y2 = this.y + Math.sin(tubeAngle) * this.size;
ctx.beginPath();
ctx.moveTo(x1, y1);
ctx.lineTo(x2, y2);
ctx.stroke();
}
const drips = 5;
for (let i = 0; i < drips; i++) {
const drip = Date.now() * 0.005 + i;
const x = this.x + (Math.sin(drip) * this.size * 0.3);
const y = this.y + this.size + (drip % 10) * 2;
ctx.fillStyle = `rgba(100, 200, 100, ${0.8 - (drip % 10) * 0.08})`;
ctx.beginPath();
ctx.arc(x, y, 1, 0, Math.PI * 2);
ctx.fill();
}
} else if (this.type === 'exploder') {
const pulseIntensity = 0.8 + Math.sin(Date.now() * 0.02) * 0.2;
ctx.strokeStyle = '#ffaa00';
ctx.lineWidth = 3;
for (let i = 0; i < 6; i++) {
const angle = (i / 6) * Math.PI * 2 + Date.now() * 0.005;
const x1 = this.x + Math.cos(angle) * this.size * 0.4;
const y1 = this.y + Math.sin(angle) * this.size * 0.4;
const x2 = this.x + Math.cos(angle) * this.size * 0.9;
const y2 = this.y + Math.sin(angle) * this.size * 0.9;
ctx.beginPath();
ctx.moveTo(x1, y1);
ctx.lineTo(x2, y2);
ctx.stroke();
}
ctx.fillStyle = `rgba(255, 200, 100, ${pulseIntensity})`;
ctx.beginPath();
ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 15;
ctx.shadowColor = '#ffaa00';
ctx.fill();
ctx.shadowBlur = 0;
ctx.fillStyle = '#ff0000';
ctx.font = 'bold 12px Arial';
ctx.textAlign = 'center';
ctx.fillText('‚ö†Ô∏è', this.x, this.y + this.size + 8);
}
ctx.fillStyle = '#ffffff';
ctx.font = 'bold 8px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.strokeStyle = '#000000';
ctx.lineWidth = 2;
const typeChar = this.type[0].toUpperCase();
ctx.strokeText(typeChar, this.x, this.y);
ctx.fillText(typeChar, this.x, this.y);
ctx.restore();
if (this.health < this.maxHealth) {
const barWidth = this.size * 2.2;
const barHeight = 5;
ctx.fillStyle = '#220000';
ctx.fillRect(this.x - barWidth/2, this.y - this.size - 12, barWidth, barHeight);
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 1;
ctx.strokeRect(this.x - barWidth/2, this.y - this.size - 12, barWidth, barHeight);
const healthPercent = this.health / this.maxHealth;
const healthColor = healthPercent > 0.6 ? '#ff4444' : healthPercent > 0.3 ? '#ff6666' : '#ff8888';
ctx.fillStyle = healthColor;
ctx.fillRect(this.x - barWidth/2 + 1, this.y - this.size - 11,
(barWidth - 2) * healthPercent, barHeight - 2);
}
ctx.fillStyle = '#ffcccc';
ctx.font = 'bold 9px Arial';
ctx.textAlign = 'center';
ctx.strokeStyle = '#000000';
ctx.lineWidth = 2;
ctx.strokeText(this.type.toUpperCase(), this.x, this.y + this.size + 20);
ctx.fillText(this.type.toUpperCase(), this.x, this.y + this.size + 20);
}
}
class Building {
constructor(x, y, type) {
this.x = x;
this.y = y;
this.type = type;
this.health = 200;
this.maxHealth = 200;
this.size = 30;
}
draw() {
const color = this.type === 'alien-nest' ? '#884422' : '#0066cc';
ctx.fillStyle = color;
ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
if (this.health < this.maxHealth) {
const barWidth = 40;
const barHeight = 5;
ctx.fillStyle = '#ff0000';
ctx.fillRect(this.x - barWidth/2, this.y - this.size/2 - 10, barWidth, barHeight);
ctx.fillStyle = '#00ff00';
ctx.fillRect(this.x - barWidth/2, this.y - this.size/2 - 10,
barWidth * (this.health / this.maxHealth), barHeight);
}
}
}
class Projectile {
constructor(x, y, angle, damage, team) {
this.x = x;
this.y = y;
this.angle = angle;
this.speed = 8;
this.damage = damage;
this.team = team;
this.life = 100; // frames to live
}
update() {
const prevX = this.x;
const prevY = this.y;
this.x += Math.cos(this.angle) * this.speed;
this.y += Math.sin(this.angle) * this.speed;
this.life--;
if (Math.random() < 0.7) {
createTrail(prevX, prevY, 0, 0, 'energy');
}
if (this.team === 'friendly') {
for (let i = enemies.length - 1; i >= 0; i--) {
const enemy = enemies[i];
if (!enemy) continue; // Safety check
const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
if (dist < enemy.size) {
const killed = enemy.takeDamage ? enemy.takeDamage(this.damage) : false;
createImpactEffect(this.x, this.y, 'organic');
if (killed) {
createExplosion(enemy.x, enemy.y, 'small');
enemies.splice(i, 1);
const rewards = {
'basic': 5,
'fast': 8,
'heavy': 15,
'spitter': 12,
'exploder': 10
};
requisition += rewards[enemy.type] || 5;
updateUI();
}
return false; // Remove projectile
}
}
for (let building of buildings) {
const dist = Math.sqrt((building.x - this.x) ** 2 + (building.y - this.y) ** 2);
if (dist < building.size/2) {
building.health -= this.damage;
createImpactEffect(this.x, this.y, 'metal');
if (building.health <= 0) {
createExplosion(building.x, building.y, 'medium');
}
return false; // Remove projectile
}
}
}
if (this.x < 0 || this.x > gameWidth || this.y < 0 || this.y > gameHeight) {
createImpactEffect(this.x, this.y, 'ground');
}
return this.life > 0 && this.x >= -10 && this.x <= gameWidth + 10 && this.y >= -10 && this.y <= gameHeight + 10;
}
draw() {
ctx.fillStyle = this.team === 'friendly' ? '#00ff88' : '#ff4444';
ctx.beginPath();
ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
ctx.fill();
}
}
class AcidProjectile extends Projectile {
constructor(x, y, angle, damage) {
super(x, y, angle, damage, 'enemy');
this.speed = 4;
this.life = 80;
this.acidTrail = [];
}
update() {
this.acidTrail.push({ x: this.x, y: this.y, life: 30 });
for (let i = this.acidTrail.length - 1; i >= 0; i--) {
this.acidTrail[i].life--;
if (this.acidTrail[i].life <= 0) {
this.acidTrail.splice(i, 1);
}
}
this.x += Math.cos(this.angle) * this.speed;
this.y += Math.sin(this.angle) * this.speed;
this.life--;
for (let i = units.length - 1; i >= 0; i--) {
const unit = units[i];
const dist = Math.sqrt((unit.x - this.x) ** 2 + (unit.y - this.y) ** 2);
if (dist < unit.size) {
unit.health -= this.damage;
createImpactEffect(this.x, this.y, 'organic');
for (let j = 0; j < 8; j++) {
particles.push(new Particle(this.x, this.y, 'smoke', {
life: 40,
size: Math.random() * 6 + 2,
color: '#44aa44'
}));
}
if (unit.health <= 0) {
units.splice(i, 1);
}
return false; // Remove projectile
}
}
return this.life > 0 && this.x >= -10 && this.x <= gameWidth + 10 && this.y >= -10 && this.y <= gameHeight + 10;
}
draw() {
for (let trail of this.acidTrail) {
ctx.save();
ctx.globalAlpha = trail.life / 30;
ctx.fillStyle = '#44aa44';
ctx.beginPath();
ctx.arc(trail.x, trail.y, 2, 0, Math.PI * 2);
ctx.fill();
ctx.restore();
}
ctx.fillStyle = '#66cc66';
ctx.beginPath();
ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
ctx.fill();
ctx.save();
ctx.globalAlpha = 0.6;
ctx.fillStyle = '#44aa44';
ctx.beginPath();
ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
ctx.fill();
ctx.restore();
}
}
function setupDefendBaseMission() {
buildings.push(new Building(gameWidth/2, gameHeight/2, 'command-center'));
units.push(new Unit(gameWidth/2 - 50, gameHeight/2 + 80, 'marine'));
units.push(new Unit(gameWidth/2, gameHeight/2 + 100, 'marine'));
units.push(new Unit(gameWidth/2 + 50, gameHeight/2 + 80, 'marine'));
units.push(new HeavyUnit(gameWidth/2 - 25, gameHeight/2 + 120));
units.push(new Turret(gameWidth/2 - 80, gameHeight/2 + 40));
units.push(new Turret(gameWidth/2 + 80, gameHeight/2 + 40));
document.getElementById('missionName').textContent = 'Defend Base Alpha';
document.getElementById('currentObjective').textContent = 'Protect Command Center';
}
function setupEliminateNestMission() {
buildings.push(new Building(gameWidth * 0.7, gameHeight * 0.3, 'alien-nest'));
buildings.push(new Building(gameWidth * 0.8, gameHeight * 0.7, 'alien-nest'));
buildings.push(new Building(gameWidth * 0.3, gameHeight * 0.2, 'alien-nest'));
const landingX = 100;
const landingY = gameHeight - 100;
units.push(new Unit(landingX, landingY, 'marine'));
units.push(new Unit(landingX + 30, landingY - 20, 'marine'));
units.push(new HeavyUnit(landingX + 15, landingY + 30));
units.push(new LaserCannon(landingX - 30, landingY + 20));
document.getElementById('missionName').textContent = 'Destroy Hive Cluster';
document.getElementById('currentObjective').textContent = 'Eliminate all nests';
}
function setupEscortMission() {
for (let i = 0; i < 2; i++) {
units.push(new Unit(100, gameHeight/2 + i * 40, 'convoy'));
}
for (let i = 0; i < 4; i++) {
units.push(new Unit(
50 + i * 30,
gameHeight/2 - 50,
'marine'
));
}
document.getElementById('missionName').textContent = 'Escort Supply Convoy';
document.getElementById('currentObjective').textContent = 'Reach extraction point';
}
function createOrbitalStrike(x, y) {
setTimeout(() => {
createExplosion(x, y, 'large');
for (let i = enemies.length - 1; i >= 0; i--) {
const enemy = enemies[i];
const dist = Math.sqrt((enemy.x - x) ** 2 + (enemy.y - y) ** 2);
if (dist < 80) {
enemy.health -= 100;
if (enemy.health <= 0) {
enemies.splice(i, 1);
requisition += 5;
}
}
}
}, 2000);
showTargetingReticle(x, y, 2000);
}
function deployReinforcements(x, y) {
setTimeout(() => {
units.push(new Unit(x - 15, y - 15, 'marine'));
units.push(new Unit(x + 15, y + 15, 'marine'));
if (Math.random() < 0.3) {
units.push(new HeavyUnit(x, y + 30));
}
createExplosion(x, y, 'small');
reinforcements += 2;
}, 1000);
}
function createSupplyDrop(x, y) {
setTimeout(() => {
createExplosion(x, y, 'small');
requisition += 50;
for (let unit of units) {
const dist = Math.sqrt((unit.x - x) ** 2 + (unit.y - y) ** 2);
if (dist < 50) {
unit.health = Math.min(unit.maxHealth, unit.health + 30);
}
}
}, 1500);
}
function createSmokeBarrage(x, y) {
for (let i = 0; i < 5; i++) {
setTimeout(() => {
const smokeX = x + (Math.random() - 0.5) * 100;
const smokeY = y + (Math.random() - 0.5) * 100;
createSmokeCloud(smokeX, smokeY);
}, i * 200);
}
}
function deployTurret(x, y) {
setTimeout(() => {
units.push(new Turret(x, y));
createExplosion(x, y, 'small');
}, 1000);
}
function deployLaserCannon(x, y) {
setTimeout(() => {
units.push(new LaserCannon(x, y));
createExplosion(x, y, 'small');
}, 1000);
}
class Turret extends Unit {
constructor(x, y) {
super(x, y, 'turret');
this.health = 150;
this.maxHealth = 150;
this.size = 20;
this.speed = 0; // Stationary
this.weapon = { damage: 35, range: 150, fireRate: 200 };
this.rotationSpeed = 0.05;
this.targetAngle = 0;
this.barrel = 0;
}
update() {
let nearestEnemy = null;
let nearestDist = this.weapon.range;
for (let enemy of enemies) {
const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
if (dist < nearestDist) {
nearestEnemy = enemy;
nearestDist = dist;
}
}
if (nearestEnemy) {
this.targetAngle = Math.atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
}
let angleDiff = this.targetAngle - this.angle;
while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
if (Math.abs(angleDiff) > 0.1) {
this.angle += Math.sign(angleDiff) * this.rotationSpeed;
}
this.findAndAttackEnemies();
}
draw() {
ctx.save();
ctx.translate(this.x, this.y);
ctx.fillStyle = '#333333';
ctx.beginPath();
ctx.arc(0, 0, this.size, 0, Math.PI * 2);
ctx.fill();
ctx.rotate(this.angle);
ctx.fillStyle = '#00aa66';
ctx.fillRect(-15, -10, 30, 20);
ctx.fillStyle = '#666666';
ctx.fillRect(15, -3, 25, 6);
if (Date.now() - this.lastShotTime < 50) {
ctx.fillStyle = '#ffff00';
ctx.beginPath();
ctx.arc(40, 0, 8, 0, Math.PI * 2);
ctx.fill();
}
ctx.restore();
if (this.health < this.maxHealth) {
const barWidth = 40;
const barHeight = 4;
ctx.fillStyle = '#ff0000';
ctx.fillRect(this.x - barWidth/2, this.y - this.size - 15, barWidth, barHeight);
ctx.fillStyle = '#00ff00';
ctx.fillRect(this.x - barWidth/2, this.y - this.size - 15,
barWidth * (this.health / this.maxHealth), barHeight);
}
if (selectedUnit === this) {
ctx.strokeStyle = '#ffaa00';
ctx.lineWidth = 2;
ctx.beginPath();
ctx.arc(this.x, this.y, this.size + 5, 0, Math.PI * 2);
ctx.stroke();
}
}
}
class LaserCannon extends Unit {
constructor(x, y) {
super(x, y, 'laser-turret');
this.health = 120;
this.maxHealth = 120;
this.size = 18;
this.speed = 0; // Stationary
this.weapon = { damage: 60, range: 200, fireRate: 800 };
this.rotationSpeed = 0.03;
this.targetAngle = 0;
this.chargeTime = 0;
this.maxChargeTime = 60; // frames to charge
this.laserBeam = null;
}
update() {
let nearestEnemy = null;
let nearestDist = this.weapon.range;
for (let enemy of enemies) {
const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
if (dist < nearestDist) {
nearestEnemy = enemy;
nearestDist = dist;
}
}
if (nearestEnemy) {
this.targetAngle = Math.atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
this.chargeTime = Math.min(this.chargeTime + 1, this.maxChargeTime);
if (this.chargeTime >= this.maxChargeTime) {
const now = Date.now();
if (now - this.lastShotTime > this.weapon.fireRate) {
this.fireLaser(nearestEnemy);
this.lastShotTime = now;
this.chargeTime = 0;
}
}
} else {
this.chargeTime = Math.max(this.chargeTime - 2, 0);
}
let angleDiff = this.targetAngle - this.angle;
while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
if (Math.abs(angleDiff) > 0.05) {
this.angle += Math.sign(angleDiff) * this.rotationSpeed;
}
}
fireLaser(target) {
this.createLaserBeam(target);
playLaserSound();
target.health -= this.weapon.damage;
createImpactEffect(target.x, target.y, 'energy');
if (target.health <= 0) {
createExplosion(target.x, target.y, 'medium');
playExplosionSound();
const index = enemies.indexOf(target);
if (index > -1) {
enemies.splice(index, 1);
requisition += 10; // Higher reward for laser kills
}
}
}
createLaserBeam(target) {
const beam = document.createElement('div');
beam.className = 'laser-beam';
const startX = this.x + Math.cos(this.angle) * 25;
const startY = this.y + Math.sin(this.angle) * 25;
const endX = target.x;
const endY = target.y;
const length = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
const angle = Math.atan2(endY - startY, endX - startX);
beam.style.left = startX + 'px';
beam.style.top = startY + 'px';
beam.style.width = length + 'px';
beam.style.transform = `rotate(${angle}rad)`;
beam.style.transformOrigin = '0 50%';
document.body.appendChild(beam);
setTimeout(() => beam.remove(), 100);
for (let i = 0; i < length; i += 20) {
const x = startX + Math.cos(angle) * i;
const y = startY + Math.sin(angle) * i;
particles.push(new Particle(x, y, 'energy', {
life: 20,
size: Math.random() * 6 + 3,
color: '#00ff88'
}));
}
}
draw() {
ctx.save();
ctx.translate(this.x, this.y);
const baseGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
baseGradient.addColorStop(0, '#334466');
baseGradient.addColorStop(0.6, '#223344');
baseGradient.addColorStop(1, '#112233');
ctx.fillStyle = baseGradient;
ctx.beginPath();
ctx.arc(0, 0, this.size, 0, Math.PI * 2);
ctx.fill();
ctx.strokeStyle = '#556677';
ctx.lineWidth = 3;
for (let i = 0; i < 8; i++) {
const angle = (i / 8) * Math.PI * 2;
const x1 = Math.cos(angle) * this.size * 0.6;
const y1 = Math.sin(angle) * this.size * 0.6;
const x2 = Math.cos(angle) * this.size * 0.9;
const y2 = Math.sin(angle) * this.size * 0.9;
ctx.beginPath();
ctx.moveTo(x1, y1);
ctx.lineTo(x2, y2);
ctx.stroke();
}
ctx.fillStyle = '#ffdd00';
ctx.beginPath();
ctx.arc(0, this.size * 0.4, 3, 0, Math.PI * 2);
ctx.fill();
ctx.rotate(this.angle);
ctx.fillStyle = '#0088cc';
ctx.fillRect(-15, -10, 30, 20);
ctx.fillStyle = '#005588';
ctx.fillRect(-12, -8, 24, 16);
const chargeIntensity = this.chargeTime / this.maxChargeTime;
ctx.fillStyle = '#003366';
ctx.fillRect(15, -6, 25, 12);
ctx.strokeStyle = '#00aadd';
ctx.lineWidth = 2;
for (let i = 0; i < 3; i++) {
ctx.beginPath();
ctx.arc(20 + i * 6, 0, 4, 0, Math.PI * 2);
ctx.stroke();
}
if (this.chargeTime > 0) {
ctx.fillStyle = `rgba(0, 255, 200, ${chargeIntensity})`;
ctx.fillRect(15, -6 * chargeIntensity, 25, 12 * chargeIntensity);
ctx.fillStyle = `rgba(0, 255, 136, ${chargeIntensity})`;
ctx.beginPath();
ctx.arc(40, 0, 8 * chargeIntensity, 0, Math.PI * 2);
ctx.fill();
for (let i = 0; i < 6; i++) {
if (Math.random() < chargeIntensity * 0.8) {
const crackleAngle = Math.random() * Math.PI * 2;
const x1 = 40 + Math.cos(crackleAngle) * 8;
const y1 = Math.sin(crackleAngle) * 8;
const x2 = x1 + Math.cos(crackleAngle) * 8;
const y2 = y1 + Math.sin(crackleAngle) * 8;
ctx.strokeStyle = `rgba(0, 255, 200, ${chargeIntensity})`;
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(x1, y1);
ctx.lineTo(x2, y2);
ctx.stroke();
}
}
}
ctx.restore();
if (this.health < this.maxHealth) {
const barWidth = 36;
const barHeight = 4;
ctx.fillStyle = '#ff0000';
ctx.fillRect(this.x - barWidth/2, this.y - this.size - 15, barWidth, barHeight);
ctx.fillStyle = '#00ff00';
ctx.fillRect(this.x - barWidth/2, this.y - this.size - 15,
barWidth * (this.health / this.maxHealth), barHeight);
}
if (this.chargeTime > 0) {
const barWidth = 36;
const barHeight = 3;
ctx.fillStyle = '#004488';
ctx.fillRect(this.x - barWidth/2, this.y + this.size + 10, barWidth, barHeight);
ctx.fillStyle = '#00ff88';
ctx.fillRect(this.x - barWidth/2, this.y + this.size + 10,
barWidth * (this.chargeTime / this.maxChargeTime), barHeight);
}
if (selectedUnit === this) {
ctx.strokeStyle = '#ffaa00';
ctx.lineWidth = 2;
ctx.beginPath();
ctx.arc(this.x, this.y, this.size + 5, 0, Math.PI * 2);
ctx.stroke();
}
}
}
class HeavyUnit extends Unit {
constructor(x, y) {
super(x, y, 'heavy');
this.health = 150;
this.maxHealth = 150;
this.size = 18;
this.speed = 0.7;
this.weapon = { damage: 45, range: 130, fireRate: 400 };
this.armor = 5; // Damage reduction
}
draw() {
ctx.save();
ctx.translate(this.x, this.y);
ctx.rotate(this.angle);
ctx.fillStyle = '#001133';
ctx.beginPath();
ctx.ellipse(-this.size * 0.5, this.size * 0.3, this.size * 0.8, this.size * 1.5, 0, 0, Math.PI * 2);
ctx.fill();
const armorGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
armorGradient.addColorStop(0, '#00ddee');
armorGradient.addColorStop(0.3, '#00bbcc');
armorGradient.addColorStop(0.7, '#008899');
armorGradient.addColorStop(1, '#005566');
ctx.fillStyle = armorGradient;
ctx.beginPath();
ctx.arc(0, 0, this.size, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = '#007788';
ctx.fillRect(-this.size + 2, -this.size/2, this.size * 2 - 4, this.size);
ctx.fillStyle = '#009999';
ctx.fillRect(-this.size * 0.6, -this.size * 0.7, this.size * 1.2, this.size * 0.8);
ctx.fillStyle = '#005566';
ctx.beginPath();
ctx.arc(-this.size * 0.7, -this.size * 0.5, 6, 0, Math.PI * 2);
ctx.fill();
ctx.beginPath();
ctx.arc(this.size * 0.7, -this.size * 0.5, 6, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = '#006677';
ctx.fillRect(-this.size * 0.8, -this.size, this.size * 1.6, this.size * 0.6);
ctx.fillStyle = '#ff4444';
ctx.fillRect(-this.size * 0.6, -this.size * 0.8, this.size * 1.2, this.size * 0.3);
ctx.strokeStyle = '#dddddd';
ctx.lineWidth = 8;
ctx.beginPath();
ctx.moveTo(this.size * 0.2, -3);
ctx.lineTo(this.size + 20, -3);
ctx.moveTo(this.size * 0.2, 3);
ctx.lineTo(this.size + 20, 3);
ctx.stroke();
ctx.strokeStyle = '#aaaaaa';
ctx.lineWidth = 2;
for (let i = 0; i < 4; i++) {
const ventX = this.size * 0.6 + i * 4;
ctx.beginPath();
ctx.moveTo(ventX, -6);
ctx.lineTo(ventX, 6);
ctx.stroke();
}
ctx.fillStyle = '#ffaa00';
ctx.beginPath();
ctx.arc(this.size + 20, -3, 3, 0, Math.PI * 2);
ctx.fill();
ctx.beginPath();
ctx.arc(this.size + 20, 3, 3, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = '#ffdd00';
ctx.font = 'bold 10px Arial';
ctx.textAlign = 'center';
ctx.fillText('‚ö°', 0, this.size * 0.4);
ctx.restore();
if (this.health < this.maxHealth) {
const barWidth = 36;
const barHeight = 5;
ctx.fillStyle = '#ff0000';
ctx.fillRect(this.x - barWidth/2, this.y - this.size - 10, barWidth, barHeight);
ctx.fillStyle = '#00ff00';
ctx.fillRect(this.x - barWidth/2, this.y - this.size - 10,
barWidth * (this.health / this.maxHealth), barHeight);
}
if (selectedUnit === this) {
ctx.strokeStyle = '#ffaa00';
ctx.lineWidth = 2;
ctx.beginPath();
ctx.arc(this.x, this.y, this.size + 5, 0, Math.PI * 2);
ctx.stroke();
}
}
}
function createExplosion(x, y, size) {
const explosion = document.createElement('div');
explosion.className = 'explosion';
explosion.style.left = (x - 50) + 'px';
explosion.style.top = (y - 50) + 'px';
if (size === 'large') {
explosion.style.width = '200px';
explosion.style.height = '200px';
explosion.style.left = (x - 100) + 'px';
explosion.style.top = (y - 100) + 'px';
}
document.body.appendChild(explosion);
setTimeout(() => explosion.remove(), 500);
playExplosionSound();
createExplosionParticles(x, y, size);
}
function createMuzzleFlash(x, y, angle = 0) {
const flash = document.createElement('div');
flash.className = 'muzzle-flash';
flash.style.left = (x - 10) + 'px';
flash.style.top = (y - 10) + 'px';
document.body.appendChild(flash);
setTimeout(() => flash.remove(), 100);
createMuzzleFlashParticles(x, y, angle);
}
function showTargetingReticle(x, y, duration) {
const reticle = document.createElement('div');
reticle.style.position = 'absolute';
reticle.style.left = (x - 40) + 'px';
reticle.style.top = (y - 40) + 'px';
reticle.style.width = '80px';
reticle.style.height = '80px';
reticle.style.border = '3px solid #ff0000';
reticle.style.borderRadius = '50%';
reticle.style.pointerEvents = 'none';
reticle.style.animation = 'pulse 0.5s infinite';
reticle.innerHTML = '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #ff0000; font-weight: bold;">TARGET</div>';
document.body.appendChild(reticle);
setTimeout(() => reticle.remove(), duration);
}
function createSmokeCloud(x, y) {
for (let i = 0; i < 10; i++) {
particles.push(new Particle(x, y, 'smoke'));
}
}
class Particle {
constructor(x, y, type, options = {}) {
this.x = x;
this.y = y;
this.type = type;
this.life = options.life || 60;
this.maxLife = this.life;
this.size = options.size || (Math.random() * 8 + 2);
this.opacity = 1;
this.rotation = Math.random() * Math.PI * 2;
this.rotationSpeed = (Math.random() - 0.5) * 0.2;
switch(type) {
case 'explosion':
this.vx = (Math.random() - 0.5) * 8;
this.vy = (Math.random() - 0.5) * 8;
this.color = options.color || ['#ffff00', '#ff8800', '#ff4400', '#ff0000'][Math.floor(Math.random() * 4)];
this.gravity = 0.1;
break;
case 'smoke':
this.vx = (Math.random() - 0.5) * 2;
this.vy = -Math.random() * 2 - 1;
this.color = options.color || '#666666';
this.gravity = -0.05;
this.expansion = 1.02;
break;
case 'spark':
this.vx = (Math.random() - 0.5) * 12;
this.vy = (Math.random() - 0.5) * 12;
this.color = options.color || '#ffff88';
this.gravity = 0.2;
this.life = 30;
this.size = Math.random() * 3 + 1;
break;
case 'debris':
this.vx = (Math.random() - 0.5) * 6;
this.vy = (Math.random() - 0.5) * 6;
this.color = options.color || '#444444';
this.gravity = 0.15;
break;
case 'energy':
this.vx = (Math.random() - 0.5) * 4;
this.vy = (Math.random() - 0.5) * 4;
this.color = options.color || '#00ff88';
this.gravity = 0;
this.pulse = Math.random() * Math.PI * 2;
break;
}
}
update() {
this.x += this.vx;
this.y += this.vy;
this.vy += this.gravity;
this.rotation += this.rotationSpeed;
this.life--;
this.pulse += 0.2;
if (this.type === 'smoke' && this.expansion) {
this.size *= this.expansion;
}
if (this.type === 'energy') {
this.size = this.size * 0.95 + Math.sin(this.pulse) * 2;
}
this.opacity = this.life / this.maxLife;
this.vx *= 0.98;
this.vy *= 0.98;
return this.life > 0;
}
draw() {
ctx.save();
ctx.globalAlpha = this.opacity;
ctx.translate(this.x, this.y);
ctx.rotate(this.rotation);
if (this.type === 'explosion') {
const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
gradient.addColorStop(0, this.color);
gradient.addColorStop(0.7, this.color + '88');
gradient.addColorStop(1, 'transparent');
ctx.fillStyle = gradient;
ctx.beginPath();
ctx.arc(0, 0, this.size, 0, Math.PI * 2);
ctx.fill();
} else if (this.type === 'smoke') {
const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
gradient.addColorStop(0, this.color + Math.floor(this.opacity * 255).toString(16).padStart(2, '0'));
gradient.addColorStop(1, 'transparent');
ctx.fillStyle = gradient;
ctx.beginPath();
ctx.arc(0, 0, this.size, 0, Math.PI * 2);
ctx.fill();
} else if (this.type === 'spark') {
ctx.fillStyle = this.color;
ctx.fillRect(-this.size/2, -1, this.size, 2);
ctx.shadowBlur = 10;
ctx.shadowColor = this.color;
ctx.fillRect(-this.size/2, -1, this.size, 2);
} else if (this.type === 'debris') {
ctx.fillStyle = this.color;
ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
} else if (this.type === 'energy') {
const glowSize = this.size + Math.sin(this.pulse) * 3;
const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
gradient.addColorStop(0, this.color);
gradient.addColorStop(0.5, this.color + '66');
gradient.addColorStop(1, 'transparent');
ctx.fillStyle = gradient;
ctx.beginPath();
ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
ctx.fill();
}
ctx.restore();
}
}
function createExplosionParticles(x, y, intensity = 'medium') {
let particleCount = 10;
let maxVelocity = 6;
if (intensity === 'large') {
particleCount = 25;
maxVelocity = 10;
} else if (intensity === 'small') {
particleCount = 5;
maxVelocity = 4;
}
for (let i = 0; i < particleCount; i++) {
particles.push(new Particle(x, y, 'explosion', {
life: 40 + Math.random() * 20,
size: Math.random() * 12 + 3
}));
}
for (let i = 0; i < particleCount / 2; i++) {
particles.push(new Particle(x, y, 'spark', {
life: 20 + Math.random() * 15,
size: Math.random() * 8 + 2
}));
}
for (let i = 0; i < particleCount / 3; i++) {
particles.push(new Particle(x, y, 'debris', {
life: 60 + Math.random() * 30,
size: Math.random() * 6 + 2
}));
}
for (let i = 0; i < 8; i++) {
setTimeout(() => {
particles.push(new Particle(
x + (Math.random() - 0.5) * 20,
y + (Math.random() - 0.5) * 20,
'smoke', {
life: 120 + Math.random() * 60,
size: Math.random() * 15 + 10
}));
}, i * 100);
}
}
function createMuzzleFlashParticles(x, y, angle) {
for (let i = 0; i < 8; i++) {
const particleAngle = angle + (Math.random() - 0.5) * 0.5;
const vx = Math.cos(particleAngle) * (Math.random() * 4 + 2);
const vy = Math.sin(particleAngle) * (Math.random() * 4 + 2);
particles.push(new Particle(x, y, 'spark', {
life: 15,
size: Math.random() * 4 + 1,
color: ['#ffff00', '#ff8800'][Math.floor(Math.random() * 2)]
}));
}
particles.push(new Particle(x, y, 'explosion', {
life: 10,
size: 8,
color: '#ffaa00'
}));
}
function createImpactEffect(x, y, surface = 'ground') {
const colors = {
ground: '#8B4513',
metal: '#C0C0C0',
organic: '#228B22'
};
for (let i = 0; i < 6; i++) {
particles.push(new Particle(x, y, 'spark', {
life: 20,
size: Math.random() * 3 + 1,
color: colors[surface] || colors.ground
}));
}
for (let i = 0; i < 4; i++) {
particles.push(new Particle(x, y, 'smoke', {
life: 40,
size: Math.random() * 8 + 4,
color: colors[surface] || colors.ground
}));
}
}
function createTrail(x, y, vx, vy, type = 'energy') {
particles.push(new Particle(x, y, type, {
life: 30,
size: Math.random() * 4 + 2
}));
}
function createSelectionEffect(x, y) {
if (!canvas) return;
const rect = canvas.getBoundingClientRect();
const screenX = rect.left + (x / gameWidth) * rect.width;
const screenY = rect.top + (y / gameHeight) * rect.height;
const effect = document.createElement('div');
effect.style.position = 'fixed'; // Use fixed instead of absolute
effect.style.left = (screenX - 20) + 'px';
effect.style.top = (screenY - 20) + 'px';
effect.style.width = '40px';
effect.style.height = '40px';
effect.style.border = '3px solid #00ff88';
effect.style.borderRadius = '50%';
effect.style.pointerEvents = 'none';
effect.style.animation = 'selectionPulse 0.5s ease-out';
effect.style.zIndex = '1000';
document.body.appendChild(effect);
setTimeout(() => effect.remove(), 500);
for (let i = 0; i < 8; i++) {
particles.push(new Particle(x, y, 'energy', {
life: 30,
size: Math.random() * 6 + 2,
color: '#00ff88'
}));
}
}
function createMoveOrderEffect(x, y) {
if (!canvas) return;
const rect = canvas.getBoundingClientRect();
const screenX = rect.left + (x / gameWidth) * rect.width;
const screenY = rect.top + (y / gameHeight) * rect.height;
const effect = document.createElement('div');
effect.style.position = 'fixed'; // Use fixed instead of absolute
effect.style.left = (screenX - 15) + 'px';
effect.style.top = (screenY - 15) + 'px';
effect.style.width = '30px';
effect.style.height = '30px';
effect.style.border = '2px solid #ffaa00';
effect.style.borderRadius = '50%';
effect.style.pointerEvents = 'none';
effect.style.animation = 'moveOrderPulse 0.8s ease-out';
effect.style.zIndex = '1000';
document.body.appendChild(effect);
setTimeout(() => effect.remove(), 800);
for (let i = 0; i < 5; i++) {
particles.push(new Particle(x, y, 'energy', {
life: 25,
size: Math.random() * 4 + 1,
color: '#ffaa00'
}));
}
}
function spawnEnemies() {
if (gameState !== 'playing') return;
const side = Math.floor(Math.random() * 4);
let x, y;
switch(side) {
case 0: x = -20; y = Math.random() * gameHeight; break;
case 1: x = gameWidth + 20; y = Math.random() * gameHeight; break;
case 2: x = Math.random() * gameWidth; y = -20; break;
case 3: x = Math.random() * gameWidth; y = gameHeight + 20; break;
}
const missionProgress = (300 - missionTime) / 300; // 0 to 1
let enemyType = 'basic';
const roll = Math.random();
if (missionProgress < 0.4) {
if (roll < 0.7) enemyType = 'basic';
else if (roll < 0.9) enemyType = 'fast';
else enemyType = 'spitter';
}
else if (missionProgress < 0.7) {
if (roll < 0.4) enemyType = 'basic';
else if (roll < 0.6) enemyType = 'fast';
else if (roll < 0.8) enemyType = 'spitter';
else if (roll < 0.95) enemyType = 'heavy';
else enemyType = 'exploder';
}
else {
if (roll < 0.3) enemyType = 'basic';
else if (roll < 0.5) enemyType = 'fast';
else if (roll < 0.7) enemyType = 'heavy';
else if (roll < 0.85) enemyType = 'spitter';
else enemyType = 'exploder';
}
enemies.push(new Enemy(x, y, enemyType));
if (Math.random() < 0.2) {
setTimeout(() => {
if (gameState === 'playing') {
const groupType = Math.random() < 0.7 ? 'basic' : 'fast';
enemies.push(new Enemy(x + (Math.random() - 0.5) * 40, y + (Math.random() - 0.5) * 40, groupType));
}
}, 500);
}
}
function spawnWave(waveType, count = 5) {
const spawnPoints = [
{ x: -20, y: gameHeight * 0.3 },
{ x: -20, y: gameHeight * 0.7 },
{ x: gameWidth + 20, y: gameHeight * 0.3 },
{ x: gameWidth + 20, y: gameHeight * 0.7 },
{ x: gameWidth * 0.3, y: -20 },
{ x: gameWidth * 0.7, y: -20 },
{ x: gameWidth * 0.3, y: gameHeight + 20 },
{ x: gameWidth * 0.7, y: gameHeight + 20 }
];
for (let i = 0; i < count; i++) {
setTimeout(() => {
const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
enemies.push(new Enemy(
spawnPoint.x + (Math.random() - 0.5) * 60,
spawnPoint.y + (Math.random() - 0.5) * 60,
waveType
));
}, i * 200);
}
}
function updateUI() {
document.getElementById('requisition').textContent = requisition;
document.getElementById('reinforcements').textContent = reinforcements;
const minutes = Math.floor(missionTime / 60);
const seconds = missionTime % 60;
document.getElementById('missionTimer').textContent =
`${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
if (selectedUnit) {
document.getElementById('selectedUnit').textContent = selectedUnit.type;
document.getElementById('unitHealth').textContent =
`${selectedUnit.health}/${selectedUnit.maxHealth}`;
document.getElementById('unitWeapon').textContent =
selectedUnit.weapon.damage > 0 ? 'Armed' : 'Unarmed';
} else {
document.getElementById('selectedUnit').textContent = 'None';
document.getElementById('unitHealth').textContent = '-/-';
document.getElementById('unitWeapon').textContent = '-';
}
}
function handleKeyDown(e) {
if (gameState !== 'playing') return;
switch(e.key) {
case 'Escape':
selectedStratagem = null;
selectedUnit = null;
document.querySelectorAll('.stratagem').forEach(s => s.classList.remove('selected'));
canvas.style.cursor = 'crosshair';
updateUI();
break;
case 'Tab':
e.preventDefault();
if (units.length > 0) {
const currentIndex = selectedUnit ? units.indexOf(selectedUnit) : -1;
const nextIndex = (currentIndex + 1) % units.length;
selectedUnit = units[nextIndex];
updateUI();
}
break;
case 'Delete':
case 'Backspace':
if (selectedUnit && confirm('Self-destruct selected unit?')) {
createExplosion(selectedUnit.x, selectedUnit.y, 'medium');
const index = units.indexOf(selectedUnit);
if (index > -1) {
units.splice(index, 1);
selectedUnit = null;
updateUI();
}
}
break;
}
}
function toggleFullscreen() {
if (!document.fullscreenElement) {
document.documentElement.requestFullscreen();
} else {
document.exitFullscreen();
}
}
let lastTime = 0;
let secondTimer = 0;
function gameLoop(currentTime) {
if (!canvas || !ctx) {
console.error('‚ùå Game loop stopped - canvas not ready');
return;
}
const deltaTime = currentTime - lastTime;
lastTime = currentTime;
secondTimer += deltaTime;
waveTimer += deltaTime;
try {
ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset any accumulated transformations
ctx.clearRect(0, 0, gameWidth, gameHeight);
} catch (e) {
console.error('‚ùå Error clearing canvas:', e);
return;
}
if (gameState === 'playing') {
if (secondTimer >= 1000) {
missionTime--;
secondTimer = 0;
updateUI();
const spawnChance = Math.min(0.4, 0.1 + (300 - missionTime) / 1000);
if (Math.random() < spawnChance) {
spawnEnemies();
}
if (missionTime % 10 === 0) {
requisition += 2;
}
}
if (currentMission && currentMission.type === 'defend-base' && waveTimer >= 20000) {
currentWave++;
waveTimer = 0;
if (currentWave <= 3) {
spawnWave('basic', 3 + currentWave);
} else if (currentWave <= 6) {
spawnWave('fast', 2 + currentWave);
setTimeout(() => spawnWave('heavy', Math.floor(currentWave / 2)), 3000);
} else {
spawnWave('heavy', currentWave - 3);
setTimeout(() => spawnWave('exploder', 2), 2000);
setTimeout(() => spawnWave('spitter', 3), 4000);
}
showWaveNotification(currentWave);
playAlertSound();
}
try {
units.forEach(unit => {
if (unit && typeof unit.update === 'function') {
unit.update();
}
});
enemies.forEach(enemy => {
if (enemy && typeof enemy.update === 'function') {
enemy.update();
}
});
} catch (e) {
console.error('‚ùå Error updating entities:', e);
}
try {
projectiles = projectiles.filter(proj => proj && proj.update && proj.update());
} catch (e) {
console.error('‚ùå Error updating projectiles:', e);
}
try {
particles = particles.filter(particle => particle && particle.update && particle.update());
} catch (e) {
console.error('‚ùå Error updating particles:', e);
}
try {
units = units.filter(unit => unit && unit.health > 0);
} catch (e) {
console.error('‚ùå Error filtering dead units:', e);
}
try {
drawAtmosphericEffects();
drawTacticalGrid();
buildings.forEach(building => {
if (building && typeof building.draw === 'function') {
building.draw();
}
});
units.forEach(unit => {
if (unit && typeof unit.draw === 'function') {
unit.draw();
}
});
enemies.forEach(enemy => {
if (enemy && typeof enemy.draw === 'function') {
enemy.draw();
}
});
projectiles.forEach(proj => {
if (proj && typeof proj.draw === 'function') {
proj.draw();
}
});
particles.forEach(particle => {
if (particle && typeof particle.draw === 'function') {
particle.draw();
}
});
drawSelectionIndicators();
} catch (e) {
console.error('‚ùå Error drawing entities:', e);
}
try {
checkMissionStatus();
} catch (e) {
console.error('‚ùå Error checking mission status:', e);
}
}
requestAnimationFrame(gameLoop);
}
function drawTacticalGrid() {
ctx.save();
ctx.strokeStyle = 'rgba(255, 215, 0, 0.15)'; /* Helldivers gold */
ctx.lineWidth = 1;
for (let x = 0; x < gameWidth; x += 50) {
ctx.beginPath();
ctx.moveTo(x, 0);
ctx.lineTo(x, gameHeight);
ctx.stroke();
}
for (let y = 0; y < gameHeight; y += 50) {
ctx.beginPath();
ctx.moveTo(0, y);
ctx.lineTo(gameWidth, y);
ctx.stroke();
}
ctx.strokeStyle = 'rgba(255, 165, 0, 0.08)'; /* Orange */
ctx.lineWidth = 0.5;
for (let x = 25; x < gameWidth; x += 50) {
ctx.beginPath();
ctx.moveTo(x, 0);
ctx.lineTo(x, gameHeight);
ctx.stroke();
}
for (let y = 25; y < gameHeight; y += 50) {
ctx.beginPath();
ctx.moveTo(0, y);
ctx.lineTo(gameWidth, y);
ctx.stroke();
}
ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
for (let x = 0; x <= gameWidth; x += 100) {
for (let y = 0; y <= gameHeight; y += 100) {
ctx.fillRect(x - 2, y - 2, 4, 4);
}
}
ctx.restore();
}
function drawAtmosphericEffects() {
ctx.save();
const windOffset = Date.now() * 0.001;
for (let i = 0; i < 15; i++) {
const x = (windOffset * 30 + i * 80) % (gameWidth + 100);
const y = 50 + i * (gameHeight / 15) + Math.sin(windOffset + i) * 20;
const size = 2 + Math.sin(windOffset * 2 + i) * 1;
ctx.fillStyle = `rgba(218, 165, 32, ${0.1 + Math.sin(windOffset + i) * 0.05})`; /* Goldenrod dust */
ctx.beginPath();
ctx.arc(x, y, size, 0, Math.PI * 2);
ctx.fill();
}
for (let layer = 0; layer < 3; layer++) {
const layerSpeed = 0.5 + layer * 0.3;
const layerOpacity = 0.03 + layer * 0.01;
for (let i = 0; i < 8; i++) {
const x = (Date.now() * layerSpeed + i * 150) % (gameWidth + 200);
const y = layer * (gameHeight / 3) + Math.sin(Date.now() * 0.002 + i) * 30;
const size = 40 + layer * 20 + Math.sin(Date.now() * 0.003 + i) * 10;
const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
gradient.addColorStop(0, `rgba(255, 140, 0, ${layerOpacity})`); /* Orange haze */
gradient.addColorStop(0.7, `rgba(255, 215, 0, ${layerOpacity * 0.5})`); /* Gold haze */
gradient.addColorStop(1, 'transparent');
ctx.fillStyle = gradient;
ctx.beginPath();
ctx.arc(x, y, size, 0, Math.PI * 2);
ctx.fill();
}
}
for (let i = 0; i < 6; i++) {
const x = (Date.now() * 0.02 + i * 120) % (gameWidth + 60);
const y = 80 + i * (gameHeight / 6) + Math.sin(Date.now() * 0.004 + i) * 15;
const rotation = Date.now() * 0.001 + i;
ctx.save();
ctx.translate(x, y);
ctx.rotate(rotation);
ctx.fillStyle = `rgba(139, 69, 19, ${0.15 + Math.sin(Date.now() * 0.002 + i) * 0.05})`; /* Brown debris */
ctx.fillRect(-2, -1, 4, 2);
ctx.restore();
}
ctx.restore();
}
function drawSelectionIndicators() {
if (selectedUnit) {
if (selectedUnit.targetX !== selectedUnit.x || selectedUnit.targetY !== selectedUnit.y) {
ctx.save();
ctx.strokeStyle = '#ffaa00';
ctx.lineWidth = 3;
ctx.setLineDash([8, 4]);
ctx.beginPath();
ctx.moveTo(selectedUnit.x, selectedUnit.y);
ctx.lineTo(selectedUnit.targetX, selectedUnit.targetY);
ctx.stroke();
const pulseSize = 15 + Math.sin(Date.now() * 0.01) * 5;
ctx.fillStyle = '#ffaa0080';
ctx.beginPath();
ctx.arc(selectedUnit.targetX, selectedUnit.targetY, pulseSize, 0, Math.PI * 2);
ctx.fill();
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 2;
ctx.beginPath();
ctx.moveTo(selectedUnit.targetX - 10, selectedUnit.targetY);
ctx.lineTo(selectedUnit.targetX + 10, selectedUnit.targetY);
ctx.moveTo(selectedUnit.targetX, selectedUnit.targetY - 10);
ctx.lineTo(selectedUnit.targetX, selectedUnit.targetY + 10);
ctx.stroke();
ctx.restore();
}
if (selectedUnit.weapon && selectedUnit.weapon.range > 0) {
ctx.save();
const alpha = 0.2 + Math.sin(Date.now() * 0.005) * 0.1;
ctx.strokeStyle = `rgba(255, 170, 0, ${alpha})`;
ctx.lineWidth = 2;
ctx.setLineDash([10, 5]);
ctx.beginPath();
ctx.arc(selectedUnit.x, selectedUnit.y, selectedUnit.weapon.range, 0, Math.PI * 2);
ctx.stroke();
ctx.fillStyle = `rgba(255, 170, 0, ${alpha * 0.3})`;
ctx.fill();
ctx.restore();
}
ctx.save();
ctx.strokeStyle = 'rgba(0, 255, 136, 0.4)';
ctx.lineWidth = 1;
ctx.setLineDash([3, 3]);
const selectionRadius = Math.max(35, (selectedUnit.size || 15) + 25);
ctx.beginPath();
ctx.arc(selectedUnit.x, selectedUnit.y, selectionRadius, 0, Math.PI * 2);
ctx.stroke();
ctx.restore();
}
}
function showWaveNotification(waveNumber) {
const notification = document.createElement('div');
notification.style.position = 'fixed';
notification.style.top = '30%';
notification.style.left = '50%';
notification.style.transform = 'translate(-50%, -50%)';
notification.style.background = 'rgba(255, 68, 68, 0.9)';
notification.style.color = 'white';
notification.style.padding = '20px 40px';
notification.style.borderRadius = '10px';
notification.style.fontSize = '24px';
notification.style.fontWeight = 'bold';
notification.style.textAlign = 'center';
notification.style.border = '3px solid #ff0000';
notification.style.boxShadow = '0 0 30px rgba(255, 0, 0, 0.8)';
notification.style.zIndex = '200';
notification.textContent = `WAVE ${waveNumber} INCOMING!`;
document.body.appendChild(notification);
setTimeout(() => notification.remove(), 3000);
}
function checkMissionStatus() {
if (currentMission) {
if (currentMission.type === 'eliminate-nest') {
const alienNests = buildings.filter(b => b.type === 'alien-nest' && b.health > 0);
if (alienNests.length === 0) {
alert('Mission Complete! All nests destroyed.');
gameState = 'mission-select';
document.getElementById('missionSelect').style.display = 'block';
resetGame();
}
} else if (currentMission.type === 'defend-base') {
const commandCenter = buildings.find(b => b.type === 'command-center');
if (!commandCenter || commandCenter.health <= 0) {
alert('Mission Failed! Command Center destroyed.');
gameState = 'mission-select';
document.getElementById('missionSelect').style.display = 'block';
resetGame();
}
}
}
if (missionTime <= 0) {
alert('Time expired! Mission Failed.');
gameState = 'mission-select';
document.getElementById('missionSelect').style.display = 'block';
resetGame();
}
}
function resetGame() {
units = [];
enemies = [];
projectiles = [];
particles = [];
buildings = [];
selectedUnit = null;
selectedStratagem = null;
requisition = 100;
reinforcements = 5;
missionTime = 300;
currentWave = 0;
waveTimer = 0;
updateUI();
}
let audioCtx = null;
let audioEnabled = true;
function initAudio() {
try {
audioCtx = new (window.AudioContext || window.webkitAudioContext)();
return true;
} catch (e) {
console.log('Audio not supported');
audioEnabled = false;
return false;
}
}
function playSound(frequency, duration, type = 'sine') {
if (!audioEnabled || !audioCtx) return;
try {
if (audioCtx.state === 'suspended') {
audioCtx.resume();
}
const oscillator = audioCtx.createOscillator();
const gainNode = audioCtx.createGain();
oscillator.connect(gainNode);
gainNode.connect(audioCtx.destination);
oscillator.frequency.value = frequency;
oscillator.type = type;
gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime); // Lower volume
gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
oscillator.start(audioCtx.currentTime);
oscillator.stop(audioCtx.currentTime + duration);
} catch (e) {
audioEnabled = false;
}
}
function playLaserSound() {
playSound(800, 0.1, 'sawtooth');
}
function playExplosionSound() {
playSound(150, 0.3, 'sawtooth');
}
function playShootSound() {
try {
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const frequencies = [200, 800, 1200]; /* Low, mid, high */
frequencies.forEach((freq, index) => {
const oscillator = audioCtx.createOscillator();
const gainNode = audioCtx.createGain();
const filter = audioCtx.createBiquadFilter();
oscillator.connect(filter);
filter.connect(gainNode);
gainNode.connect(audioCtx.destination);
oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
oscillator.frequency.exponentialRampToValueAtTime(freq * 0.3, audioCtx.currentTime + 0.1);
oscillator.type = index === 0 ? 'sawtooth' : index === 1 ? 'square' : 'triangle';
filter.type = 'lowpass';
filter.frequency.setValueAtTime(2000, audioCtx.currentTime);
const volume = 0.02 + index * 0.01;
gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
oscillator.start(audioCtx.currentTime);
oscillator.stop(audioCtx.currentTime + 0.15);
});
} catch (e) {
playSound(400, 0.05, 'square');
}
}
function playAlertSound() {
playSound(1000, 0.2, 'triangle');
}
document.addEventListener('keydown', (e) => {
if (gameState !== 'playing') return;
switch(e.key.toLowerCase()) {
case '1':
selectStratagem('orbital-strike');
break;
case '2':
selectStratagem('reinforcements');
break;
case '3':
selectStratagem('supply-drop');
break;
case '4':
selectStratagem('smoke-barrage');
break;
case '5':
selectStratagem('heavy-turret');
break;
case '6':
selectStratagem('laser-cannon');
break;
case 'space':
e.preventDefault();
if (selectedUnit) {
let nearestEnemy = null;
let nearestDist = Infinity;
for (let enemy of enemies) {
const dist = Math.sqrt((enemy.x - selectedUnit.x) ** 2 + (enemy.y - selectedUnit.y) ** 2);
if (dist < nearestDist) {
nearestEnemy = enemy;
nearestDist = dist;
}
}
if (nearestEnemy) {
selectedUnit.targetX = nearestEnemy.x;
selectedUnit.targetY = nearestEnemy.y;
}
}
break;
}
});
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', init);
} else {
init();
}</script>
</body>
</html>