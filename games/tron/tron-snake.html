<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRON: Grid Snake</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', 'Orbitron', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        canvas {
            border: 2px solid #00D9FF;
            box-shadow:
                0 0 10px #00D9FF,
                0 0 20px #00D9FF,
                0 0 40px #00D9FF;
            display: block;
            background: #000;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2rem;
            pointer-events: none;
            z-index: 10;
        }

        .hud-item {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border: 2px solid #00D9FF;
            clip-path: polygon(10% 0%, 100% 0%, 90% 100%, 0% 100%);
            box-shadow:
                0 0 10px #00D9FF,
                0 0 20px #00D9FF;
            text-align: center;
        }

        .hud-label {
            font-family: 'Orbitron', monospace;
            font-size: 0.8rem;
            color: #00D9FF;
            text-transform: uppercase;
            letter-spacing: 0.2em;
        }

        .hud-value {
            font-family: 'Orbitron', monospace;
            font-size: 1.8rem;
            color: #fff;
            text-shadow:
                0 0 5px #00D9FF,
                0 0 10px #00D9FF;
            font-weight: 700;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .overlay.hidden {
            display: none;
        }

        .overlay-title {
            font-family: 'Orbitron', monospace;
            font-size: clamp(2.5rem, 10vw, 5rem);
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: #fff;
            text-shadow:
                0 0 7px #fff,
                0 0 10px #fff,
                0 0 21px #fff,
                0 0 42px #00D9FF,
                0 0 82px #00D9FF,
                0 0 92px #00D9FF;
            margin-bottom: 2rem;
        }

        .btn {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            padding: 15px 40px;
            margin: 10px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00D9FF;
            color: #00D9FF;
            cursor: pointer;
            clip-path: polygon(5% 0%, 100% 0%, 95% 100%, 0% 100%);
            transition: all 0.3s ease;
            box-shadow:
                0 0 10px #00D9FF,
                0 0 20px #00D9FF;
        }

        .btn:hover {
            background: #00D9FF;
            color: #000;
            transform: translateY(-5px);
            box-shadow:
                0 0 20px #00D9FF,
                0 0 40px #00D9FF;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
        }

        .back-btn {
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00D9FF;
            color: #00D9FF;
            text-decoration: none;
            display: inline-block;
            clip-path: polygon(0% 0%, 90% 0%, 100% 100%, 10% 100%);
            transition: all 0.3s ease;
            box-shadow:
                0 0 10px #00D9FF,
                0 0 20px #00D9FF;
        }

        .back-btn:hover {
            background: #00D9FF;
            color: #000;
            box-shadow:
                0 0 20px #00D9FF,
                0 0 40px #00D9FF;
        }

        .game-over-stats {
            margin: 2rem 0;
            padding: 30px 50px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #FF0000;
            box-shadow:
                0 0 10px #FF0000,
                0 0 20px #FF0000;
        }

        .stat-line {
            font-family: 'Rajdhani', monospace;
            font-size: 1.3rem;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            min-width: 300px;
        }

        .controls-hint {
            font-family: 'Rajdhani', monospace;
            font-size: 1rem;
            color: #00D9FF;
            margin-top: 2rem;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="back-link">
        <a href="../../tron-index.html" class="back-btn">‚Üê GRID</a>
    </div>

    <div class="hud">
        <div class="hud-item">
            <div class="hud-label">Score</div>
            <div class="hud-value" id="score">0</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">High Score</div>
            <div class="hud-value" id="highScore">0</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Start Screen -->
    <div class="overlay" id="startScreen">
        <h1 class="overlay-title">GRID SNAKE</h1>
        <button class="btn" id="startBtn">INITIALIZE</button>
        <p class="controls-hint">Arrow Keys / WASD / Swipe to Control</p>
    </div>

    <!-- Game Over Screen -->
    <div class="overlay hidden" id="gameOverScreen">
        <h1 class="overlay-title">DEREZZED</h1>
        <div class="game-over-stats" id="stats">
            <div class="stat-line">
                <span>FINAL SCORE:</span>
                <span id="finalScore">0</span>
            </div>
            <div class="stat-line">
                <span>HIGH SCORE:</span>
                <span id="finalHighScore">0</span>
            </div>
        </div>
        <button class="btn" id="restartBtn">RESTART</button>
        <button class="btn" id="menuBtn">EXIT</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game settings
        const GRID_SIZE = 20;
        const CANVAS_SIZE = Math.min(600, Math.min(window.innerWidth - 40, window.innerHeight - 140));
        canvas.width = CANVAS_SIZE;
        canvas.height = CANVAS_SIZE;

        const TILE_COUNT = CANVAS_SIZE / GRID_SIZE;
        const SPEED = 100; // ms per move

        // Audio
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Game state
        let snake = [];
        let food = {};
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let score = 0;
        let highScore = localStorage.getItem('tronSnakeHighScore') || 0;
        let gameRunning = false;
        let gameLoop;

        // Initialize
        document.getElementById('highScore').textContent = highScore;

        function init() {
            snake = [
                { x: Math.floor(TILE_COUNT / 2), y: Math.floor(TILE_COUNT / 2) }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            spawnFood();
            updateScore();
        }

        function spawnFood() {
            do {
                food = {
                    x: Math.floor(Math.random() * TILE_COUNT),
                    y: Math.floor(Math.random() * TILE_COUNT)
                };
            } while (snake.some(segment => segment.x === food.x && segment.y === food.y));
        }

        function update() {
            if (!gameRunning) return;

            // Update direction
            direction = nextDirection;

            // Move snake
            const head = {
                x: snake[0].x + direction.x,
                y: snake[0].y + direction.y
            };

            // Check wall collision
            if (head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT) {
                gameOver();
                return;
            }

            // Check self collision
            if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                gameOver();
                return;
            }

            snake.unshift(head);

            // Check food
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                updateScore();
                spawnFood();
                playSound('eat');
            } else {
                snake.pop();
            }

            draw();
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(0, 217, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= TILE_COUNT; i++) {
                ctx.beginPath();
                ctx.moveTo(i * GRID_SIZE, 0);
                ctx.lineTo(i * GRID_SIZE, canvas.height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * GRID_SIZE);
                ctx.lineTo(canvas.width, i * GRID_SIZE);
                ctx.stroke();
            }

            // Draw snake
            snake.forEach((segment, index) => {
                const alpha = 1 - (index / snake.length) * 0.5;

                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00D9FF';

                if (index === 0) {
                    // Head - brighter
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 30;
                } else {
                    ctx.fillStyle = `rgba(0, 217, 255, ${alpha})`;
                }

                ctx.fillRect(
                    segment.x * GRID_SIZE + 2,
                    segment.y * GRID_SIZE + 2,
                    GRID_SIZE - 4,
                    GRID_SIZE - 4
                );
            });

            // Draw food
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#FF0000';
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(
                food.x * GRID_SIZE + 4,
                food.y * GRID_SIZE + 4,
                GRID_SIZE - 8,
                GRID_SIZE - 8
            );

            // Draw food glow
            ctx.shadowBlur = 40;
            ctx.fillStyle = '#fff';
            ctx.fillRect(
                food.x * GRID_SIZE + 8,
                food.y * GRID_SIZE + 8,
                GRID_SIZE - 16,
                GRID_SIZE - 16
            );

            ctx.shadowBlur = 0;
        }

        function updateScore() {
            document.getElementById('score').textContent = score;
        }

        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            gameRunning = true;
            init();
            draw();
            gameLoop = setInterval(update, SPEED);
            playSound('start');
        }

        function gameOver() {
            gameRunning = false;
            clearInterval(gameLoop);

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('tronSnakeHighScore', highScore);
                document.getElementById('highScore').textContent = highScore;
            }

            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalHighScore').textContent = highScore;
            document.getElementById('gameOverScreen').classList.remove('hidden');
            playSound('crash');
        }

        function changeDirection(newDir) {
            // Prevent 180-degree turns
            if (direction.x + newDir.x === 0 && direction.y + newDir.y === 0) {
                return;
            }
            nextDirection = newDir;
        }

        // Controls
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;

            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    changeDirection({ x: 0, y: -1 });
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    changeDirection({ x: 0, y: 1 });
                    e.preventDefault();
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    changeDirection({ x: -1, y: 0 });
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    changeDirection({ x: 1, y: 0 });
                    e.preventDefault();
                    break;
            }
        });

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (!gameRunning) return;

            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                changeDirection(deltaX > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 });
            } else {
                changeDirection(deltaY > 0 ? { x: 0, y: 1 } : { x: 0, y: -1 });
            }

            e.preventDefault();
        }, { passive: false });

        // Buttons
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', () => {
            document.getElementById('gameOverScreen').classList.add('hidden');
            startGame();
        });
        document.getElementById('menuBtn').addEventListener('click', () => {
            window.location.href = '../../tron-index.html';
        });

        // Sound effects
        function playSound(type) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            switch(type) {
                case 'start':
                    oscillator.frequency.value = 400;
                    gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.3);
                    break;
                case 'eat':
                    oscillator.frequency.value = 600;
                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.1);
                    break;
                case 'crash':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.3);
                    break;
            }
        }
    </script>
</body>
</html>
