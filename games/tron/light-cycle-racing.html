<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRON: Light Cycle Racing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Arial Narrow', Arial, monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        .game-container {
            position: relative;
            max-width: 100%;
            max-height: 100vh;
        }

        canvas {
            border: 2px solid #00D9FF;
            box-shadow:
                0 0 10px #00D9FF,
                0 0 20px #00D9FF,
                0 0 40px #00D9FF;
            display: block;
            background: #000;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
        }

        .hud-item {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border: 2px solid #00D9FF;
            clip-path: polygon(10% 0%, 100% 0%, 90% 100%, 0% 100%);
            box-shadow:
                0 0 10px #00D9FF,
                0 0 20px #00D9FF,
                inset 0 0 20px rgba(0, 217, 255, 0.1);
        }

        .hud-label {
            font-family: monospace;
            font-size: 0.8rem;
            color: #00D9FF;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            opacity: 0.7;
        }

        .hud-value {
            font-family: monospace;
            font-size: 1.5rem;
            color: #fff;
            text-shadow:
                0 0 5px #00D9FF,
                0 0 10px #00D9FF;
            font-weight: 700;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .overlay.hidden {
            display: none;
        }

        .overlay-title {
            font-family: monospace;
            font-size: clamp(2rem, 8vw, 4rem);
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: #fff;
            text-shadow:
                0 0 7px #fff,
                0 0 10px #fff,
                0 0 21px #fff,
                0 0 42px #00D9FF,
                0 0 82px #00D9FF,
                0 0 92px #00D9FF;
            margin-bottom: 2rem;
        }

        .overlay-subtitle {
            font-family: monospace;
            font-size: clamp(1rem, 3vw, 1.5rem);
            color: #00D9FF;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            margin-bottom: 3rem;
        }

        .btn {
            font-family: monospace;
            font-size: 1.2rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            padding: 15px 40px;
            margin: 10px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00D9FF;
            color: #00D9FF;
            cursor: pointer;
            clip-path: polygon(5% 0%, 100% 0%, 95% 100%, 0% 100%);
            transition: all 0.3s ease;
            box-shadow:
                0 0 10px #00D9FF,
                0 0 20px #00D9FF;
        }

        .btn:hover {
            background: #00D9FF;
            color: #000;
            transform: translateY(-5px);
            box-shadow:
                0 0 20px #00D9FF,
                0 0 40px #00D9FF;
        }

        .controls-info {
            margin-top: 2rem;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #00D9FF;
            max-width: 500px;
            text-align: center;
        }

        .controls-info h3 {
            font-family: monospace;
            color: #00D9FF;
            margin-bottom: 1rem;
            letter-spacing: 0.1em;
        }

        .controls-info p {
            font-family: monospace;
            color: #fff;
            line-height: 1.8;
            margin: 0.5rem 0;
        }

        .game-over-stats {
            margin: 2rem 0;
            padding: 20px 40px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #FF0000;
            box-shadow:
                0 0 10px #FF0000,
                0 0 20px #FF0000;
        }

        .stat-line {
            font-family: monospace;
            font-size: 1.2rem;
            color: #fff;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            min-width: 300px;
        }

        .stat-label {
            color: #FF6666;
        }

        .stat-value {
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 5px #FF0000;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
        }

        .back-btn {
            font-family: monospace;
            font-size: 1rem;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00D9FF;
            color: #00D9FF;
            text-decoration: none;
            display: inline-block;
            clip-path: polygon(0% 0%, 90% 0%, 100% 100%, 10% 100%);
            transition: all 0.3s ease;
            box-shadow:
                0 0 10px #00D9FF,
                0 0 20px #00D9FF;
        }

        .back-btn:hover {
            background: #00D9FF;
            color: #000;
            box-shadow:
                0 0 20px #00D9FF,
                0 0 40px #00D9FF;
        }

        @media (max-width: 768px) {
            .hud {
                flex-direction: column;
                gap: 10px;
            }

            .hud-item {
                padding: 10px 15px;
            }

            .hud-value {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="back-link">
        <a href="../../tron-index.html" class="back-btn">‚Üê GRID</a>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>

        <div class="hud">
            <div class="hud-item">
                <div class="hud-label">Score</div>
                <div class="hud-value" id="score">0</div>
            </div>
            <div class="hud-item">
                <div class="hud-label">High Score</div>
                <div class="hud-value" id="highScore">0</div>
            </div>
            <div class="hud-item">
                <div class="hud-label">Speed</div>
                <div class="hud-value" id="speed">1.0x</div>
            </div>
        </div>

        <!-- Start Screen -->
        <div class="overlay" id="startScreen">
            <h1 class="overlay-title">LIGHT CYCLE</h1>
            <p class="overlay-subtitle">Grid Combat Protocol</p>
            <button class="btn" id="startBtn">ENTER GRID</button>

            <div class="controls-info">
                <h3>CONTROLS</h3>
                <p>Arrow Keys or WASD - Navigate</p>
                <p>Avoid walls and light trails</p>
                <p>Survive longer than opponents</p>
                <p>Speed increases over time</p>

                <h3 style="margin-top: 2rem;">DIFFICULTY</h3>
                <select id="difficultySelect" style="width: 100%; padding: 10px; margin-top: 10px; background: rgba(0, 217, 255, 0.1); border: 1px solid #00D9FF; color: #fff; font-size: 1rem; font-family: monospace;">
                    <option value="easy">EASY - Random AI</option>
                    <option value="medium" selected>MEDIUM - Smart AI</option>
                    <option value="hard">HARD - Expert AI</option>
                </select>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div class="overlay hidden" id="gameOverScreen">
            <h1 class="overlay-title">PROGRAM TERMINATED</h1>
            <div class="game-over-stats" id="gameOverStats"></div>
            <button class="btn" id="restartBtn">RE-ENTER GRID</button>
            <button class="btn" id="menuBtn">EXIT TO GRID</button>
        </div>
    </div>

    <script>
        // DEBUG mode pattern - set to true to see collision details
        const DEBUG = false;
        if (!DEBUG) {
            const noop = () => {};
            console.log = noop;
            console.warn = noop;
            console.info = noop;
        }

        // Debug helper
        function debugLog(message) {
            if (DEBUG) console.log(message);
        }

        // Safe localStorage wrapper
        function safeGetItem(key, defaultValue = null) {
            try {
                const item = localStorage.getItem(key);
                return item !== null ? item : defaultValue;
            } catch (error) {
                console.error('LocalStorage not available:', error);
                return defaultValue;
            }
        }

        function safeSetItem(key, value) {
            try {
                localStorage.setItem(key, value);
                return true;
            } catch (error) {
                console.error('LocalStorage not available:', error);
                return false;
            }
        }

        // EventManager for memory leak prevention
        class EventManager {
            constructor() {
                this.listeners = [];
            }

            add(element, event, handler, options) {
                element.addEventListener(event, handler, options);
                this.listeners.push({ element, event, handler, options });
            }

            removeAll() {
                this.listeners.forEach(({ element, event, handler, options }) => {
                    element.removeEventListener(event, handler, options);
                });
                this.listeners = [];
            }
        }

        const eventManager = new EventManager();

        // SpatialGrid for O(1) collision detection
        class SpatialGrid {
            constructor(width, height, gridSize) {
                this.cols = Math.ceil(width / gridSize);
                this.rows = Math.ceil(height / gridSize);
                this.gridSize = gridSize;
                this.grid = new Array(this.rows).fill(null).map(() => new Array(this.cols).fill(false));
            }

            markOccupied(x, y) {
                const col = Math.floor(x / this.gridSize);
                const row = Math.floor(y / this.gridSize);
                if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
                    this.grid[row][col] = true;
                }
            }

            isOccupied(x, y) {
                const col = Math.floor(x / this.gridSize);
                const row = Math.floor(y / this.gridSize);
                if (row < 0 || row >= this.rows || col < 0 || col >= this.cols) return true;
                return this.grid[row][col];
            }
        }

        // Global spatial grid caching
        let globalSpatialGrid = null;
        let lastGridUpdate = 0;
        let frameCount = 0;

        function getGlobalSpatialGrid() {
            if (globalSpatialGrid && lastGridUpdate === frameCount) {
                return globalSpatialGrid;
            }

            globalSpatialGrid = new SpatialGrid(canvas.width, canvas.height, GRID_SIZE);
            for (const cycle of lightCycles) {
                for (const segment of cycle.trail) {
                    globalSpatialGrid.markOccupied(segment.x, segment.y);
                }
            }
            lastGridUpdate = frameCount;
            return globalSpatialGrid;
        }

        // Flood fill algorithm for space evaluation
        function floodFill(startX, startY, spatialGrid, maxDepth = 200) {
            const visited = new Set();
            const queue = [{x: startX, y: startY, depth: 0}];
            let spaceCount = 0;

            while (queue.length > 0 && spaceCount < maxDepth) {
                const {x, y, depth} = queue.shift();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                if (spatialGrid.isOccupied(x, y)) continue;

                visited.add(key);
                spaceCount++;

                // Add neighbors
                const directions = [
                    {x: x + GRID_SIZE, y: y},
                    {x: x - GRID_SIZE, y: y},
                    {x: x, y: y + GRID_SIZE},
                    {x: x, y: y - GRID_SIZE}
                ];

                for (const next of directions) {
                    if (!visited.has(`${next.x},${next.y}`)) {
                        queue.push({...next, depth: depth + 1});
                    }
                }
            }

            return spaceCount;
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game constants
        const GRID_SIZE = 10;
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const INITIAL_SPEED = 100;
        const SPEED_INCREASE = 0.5;
        const AI_COUNT = 3;

        // Set canvas size
        canvas.width = Math.min(CANVAS_WIDTH, window.innerWidth - 40);
        canvas.height = Math.min(CANVAS_HEIGHT, window.innerHeight - 40);

        // Game state
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let gameSpeed = INITIAL_SPEED;
        let lastUpdateTime = 0;
        let survivedTime = 0;
        let highScore = parseInt(safeGetItem('tronLightCycleHighScore', '0'));
        let difficulty = 'medium';

        // Audio context
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Direction constants
        const DIR = {
            UP: { x: 0, y: -1 },
            DOWN: { x: 0, y: 1 },
            LEFT: { x: -1, y: 0 },
            RIGHT: { x: 1, y: 0 }
        };

        // Player
        class LightCycle {
            constructor(x, y, direction, color, isPlayer = false) {
                this.x = Math.floor(x / GRID_SIZE) * GRID_SIZE;
                this.y = Math.floor(y / GRID_SIZE) * GRID_SIZE;
                this.direction = direction;
                this.color = color;
                this.trail = [];
                this.alive = true;
                this.isPlayer = isPlayer;
                this.nextDirection = direction;
            }

            update() {
                if (!this.alive) return;

                // Add current position to trail
                this.trail.push({ x: this.x, y: this.y });

                // Update direction
                this.direction = this.nextDirection;

                // Move
                this.x += this.direction.x * GRID_SIZE;
                this.y += this.direction.y * GRID_SIZE;
            }

            checkCollisionsPhase() {
                if (!this.alive) return;
                this.checkCollisions();
            }

            checkCollisions() {
                const cycleType = this.isPlayer ? 'PLAYER' : 'AI';

                // Wall collision
                if (this.x < 0 || this.x >= canvas.width ||
                    this.y < 0 || this.y >= canvas.height) {
                    debugLog(`${cycleType} died: Wall collision at (${this.x}, ${this.y})`);
                    this.alive = false;
                    playSound('crash');
                    return;
                }

                // Check collision with other cycles' current positions (head-on collisions)
                for (const cycle of lightCycles) {
                    if (cycle !== this && cycle.alive) {
                        if (this.x === cycle.x && this.y === cycle.y) {
                            const otherType = cycle.isPlayer ? 'PLAYER' : 'AI';
                            debugLog(`${cycleType} died: Head-on collision with ${otherType} at (${this.x}, ${this.y})`);
                            this.alive = false;
                            playSound('crash');
                            return;
                        }
                    }
                }

                // Check collision with all trails (including own)
                for (const cycle of lightCycles) {
                    for (const segment of cycle.trail) {
                        if (this.x === segment.x && this.y === segment.y) {
                            const trailOwner = cycle.isPlayer ? 'PLAYER' : 'AI';
                            const ownTrail = cycle === this ? ' (own trail)' : '';
                            debugLog(`${cycleType} died: Trail collision with ${trailOwner}'s trail${ownTrail} at (${this.x}, ${this.y})`);
                            this.alive = false;
                            playSound('crash');
                            return;
                        }
                    }
                }
            }

            changeDirection(newDir) {
                // Prevent 180-degree turns
                if (this.direction.x + newDir.x === 0 &&
                    this.direction.y + newDir.y === 0) {
                    return;
                }
                this.nextDirection = newDir;
            }

            draw() {
                if (!this.alive) return;

                // Draw trail
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = GRID_SIZE - 2;
                ctx.lineCap = 'square';
                ctx.lineJoin = 'miter';

                if (this.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x + GRID_SIZE/2, this.trail[0].y + GRID_SIZE/2);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x + GRID_SIZE/2, this.trail[i].y + GRID_SIZE/2);
                    }
                    ctx.lineTo(this.x + GRID_SIZE/2, this.y + GRID_SIZE/2);
                    ctx.stroke();
                }

                // Draw cycle (brighter than trail)
                ctx.shadowBlur = 30;
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x + 2, this.y + 2, GRID_SIZE - 4, GRID_SIZE - 4);

                // Draw direction indicator
                ctx.shadowBlur = 40;
                ctx.fillStyle = this.color;
                const indicatorX = this.x + GRID_SIZE/2 + this.direction.x * GRID_SIZE/2;
                const indicatorY = this.y + GRID_SIZE/2 + this.direction.y * GRID_SIZE/2;
                ctx.beginPath();
                ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
            }
        }

        // AI Logic - Intelligent with space awareness
        class AICycle extends LightCycle {
            constructor(x, y, direction, color, difficulty) {
                super(x, y, direction, color, false);
                this.difficulty = difficulty;
                this.decisionTimer = 0;

                // Adjust decision delay based on difficulty
                if (difficulty === 'easy') {
                    this.decisionDelay = 5;
                } else if (difficulty === 'medium') {
                    this.decisionDelay = 3;
                } else {
                    this.decisionDelay = 1; // Hard AI reacts much faster
                }
            }

            updateAI() {
                if (!this.alive) return;

                this.decisionTimer++;
                if (this.decisionTimer < this.decisionDelay) return;
                this.decisionTimer = 0;

                // Use different AI strategies based on difficulty
                if (this.difficulty === 'easy') {
                    this.simpleAI();
                } else if (this.difficulty === 'medium') {
                    this.smartAI();
                } else {
                    this.expertAI();
                }
            }

            // Easy AI: Original random behavior
            simpleAI() {
                const possibleDirections = [DIR.UP, DIR.DOWN, DIR.LEFT, DIR.RIGHT];
                const validDirections = [];

                for (const dir of possibleDirections) {
                    if (this.direction.x + dir.x === 0 && this.direction.y + dir.y === 0) {
                        continue;
                    }

                    const testX = this.x + dir.x * GRID_SIZE;
                    const testY = this.y + dir.y * GRID_SIZE;

                    if (!this.isImmediateCollision(testX, testY)) {
                        validDirections.push(dir);
                    }
                }

                if (validDirections.length > 0) {
                    const straightIsSafe = validDirections.some(dir =>
                        dir.x === this.direction.x && dir.y === this.direction.y
                    );

                    if (straightIsSafe && Math.random() > 0.3) {
                        return;
                    }

                    const randomDir = validDirections[Math.floor(Math.random() * validDirections.length)];
                    this.changeDirection(randomDir);
                }
            }

            // Medium AI: Use new AI Brain system
            smartAI() {
                if (!this.aiBrain) {
                    this.aiBrain = new AIBrain(this.difficulty, this);
                }

                const decision = this.aiBrain.decideMove(player, []);
                if (decision) {
                    this.changeDirection(decision);
                }
            }

            // Hard AI: Ultimate Intercept & Cutoff Strategy
            expertAI() {
                if (!player || !player.alive) return;

                // Step 1: Get all safe moves (Safety First!)
                const possibleDirs = [DIR.UP, DIR.DOWN, DIR.LEFT, DIR.RIGHT];
                const safeMoves = [];

                for (const dir of possibleDirs) {
                    // Skip 180-degree turns
                    if (this.direction.x + dir.x === 0 && this.direction.y + dir.y === 0) {
                        continue;
                    }

                    const testX = this.x + dir.x * GRID_SIZE;
                    const testY = this.y + dir.y * GRID_SIZE;

                    // Check if move is valid
                    if (this.isImmediateCollision(testX, testY)) {
                        continue;
                    }

                    // Calculate available space in this direction
                    const spatialGrid = getGlobalSpatialGrid();
                    const space = floodFill(testX, testY, spatialGrid, 200);

                    // Require minimum safe space (20 for hard mode)
                    if (space >= 20) {
                        safeMoves.push({ direction: dir, space, x: testX, y: testY });
                    }
                }

                // Emergency: No safe moves, take best available
                if (safeMoves.length === 0) {
                    for (const dir of possibleDirs) {
                        if (this.direction.x + dir.x === 0 && this.direction.y + dir.y === 0) continue;
                        const testX = this.x + dir.x * GRID_SIZE;
                        const testY = this.y + dir.y * GRID_SIZE;
                        if (!this.isImmediateCollision(testX, testY)) {
                            this.changeDirection(dir);
                            return;
                        }
                    }
                    return; // No moves available
                }

                // Step 2: From safe moves, choose most aggressive
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const playerDir = player.direction;

                // Determine if we're AHEAD of player (in his movement direction)
                let isAhead = false;
                if (playerDir.x > 0) isAhead = (dx < 0); // Player moving right, we're left of him = ahead
                if (playerDir.x < 0) isAhead = (dx > 0); // Player moving left, we're right of him = ahead
                if (playerDir.y > 0) isAhead = (dy < 0); // Player moving down, we're above = ahead
                if (playerDir.y < 0) isAhead = (dy > 0); // Player moving up, we're below = ahead

                if (!isAhead) {
                    // OVERTAKE MODE: We're behind, need to get ahead
                    // Strategy: Move in SAME direction as player to parallel overtake
                    safeMoves.forEach(move => {
                        // Bonus for moving in player's direction
                        const parallelScore = (move.direction.x === playerDir.x && move.direction.y === playerDir.y) ? 500 : 0;

                        // Also bonus for getting closer to being "ahead"
                        const futureX = move.x + playerDir.x * GRID_SIZE * 5;
                        const futureY = move.y + playerDir.y * GRID_SIZE * 5;
                        const distToFuturePlayer = Math.sqrt(Math.pow(futureX - move.x, 2) + Math.pow(futureY - move.y, 2));
                        const overtakeBonus = Math.max(0, 300 - distToFuturePlayer) * 0.8;

                        move.score = move.space * 0.1 + parallelScore + overtakeBonus;
                    });
                } else {
                    // CUTOFF MODE: We're ahead, cut him off!
                    safeMoves.forEach(move => {
                        // Calculate perpendicular distance to player's path
                        let perpDist;
                        if (playerDir.x !== 0) {
                            perpDist = Math.abs(dy); // Horizontal movement, vertical distance matters
                        } else {
                            perpDist = Math.abs(dx); // Vertical movement, horizontal distance matters
                        }

                        // If close enough to player's path, move perpendicular to block
                        if (perpDist < 150) {
                            // Bonus for moving PERPENDICULAR to player direction (creates wall)
                            const isPerpendicular = (playerDir.x !== 0 && move.direction.y !== 0) ||
                                                   (playerDir.y !== 0 && move.direction.x !== 0);
                            const cutoffBonus = isPerpendicular ? 400 : 0;

                            // Also bonus for moving TOWARDS player's path
                            const approachBonus = (perpDist > 0) ? (150 - perpDist) * 2 : 0;

                            move.score = move.space * 0.1 + cutoffBonus + approachBonus;
                        } else {
                            // Too far from path, get closer first
                            const approachBonus = Math.max(0, 200 - perpDist) * 1.5;
                            move.score = move.space * 0.2 + approachBonus;
                        }
                    });
                }

                // Step 3: Choose best move
                safeMoves.sort((a, b) => b.score - a.score);
                this.changeDirection(safeMoves[0].direction);
            }

            isImmediateCollision(x, y) {
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
                    return true;
                }

                // Check collision with other cycles' current positions
                for (const cycle of lightCycles) {
                    if (cycle !== this && cycle.alive) {
                        if (x === cycle.x && y === cycle.y) {
                            return true;
                        }
                    }
                }

                // Check collision with all trails
                for (const cycle of lightCycles) {
                    for (const segment of cycle.trail) {
                        if (x === segment.x && y === segment.y) {
                            return true;
                        }
                    }
                }

                return false;
            }
        }

        // ==================== NEW AI BRAIN SYSTEM ====================

        // AI Brain - manages strategy selection and switching
        class AIBrain {
            constructor(difficulty, aiCycle) {
                this.difficulty = difficulty;
                this.aiCycle = aiCycle;
                this.moveCount = 0;
                this.strategyTimer = Math.floor(Math.random() * 5) + 5; // 5-10 moves until first switch
                this.currentStrategy = null;
                this.lastPlayerPos = null;
                this.playerTurnCount = 0;
                this.playerMovementHistory = [];
                this.initialized = false;

                // Don't initialize strategy in constructor - wait for first move
            }

            selectNewStrategy() {
                const weights = this.getStrategyWeights();
                const strategies = [
                    { name: 'aggressive', weight: weights.aggressive, strategy: () => new AggressiveHunter(this.aiCycle, this.difficulty) },
                    { name: 'territory', weight: weights.territory, strategy: () => new TerritoryController(this.aiCycle, this.difficulty) },
                    { name: 'mirror', weight: weights.mirror, strategy: () => new MirrorPlayer(this.aiCycle, this.difficulty) },
                    { name: 'chaotic', weight: weights.chaotic, strategy: () => new ChaoticJester(this.aiCycle, this.difficulty) },
                    { name: 'adaptive', weight: weights.adaptive, strategy: () => new AdaptiveLearner(this.aiCycle, this.difficulty) },
                    { name: 'trapper', weight: weights.trapper, strategy: () => new TrapperStrategy(this.aiCycle, this.difficulty) }
                ];

                // Hard mode: Always start with an aggressive strategy
                if (this.difficulty === 'hard' && !this.initialized) {
                    const aggressiveStrategies = ['aggressive', 'adaptive', 'trapper'];
                    const randomAggressive = aggressiveStrategies[Math.floor(Math.random() * aggressiveStrategies.length)];
                    const chosenStrategy = strategies.find(s => s.name === randomAggressive);
                    this.currentStrategy = chosenStrategy.strategy();
                    this.strategyTimer = Math.floor(Math.random() * 8) + 8; // 8-15 moves
                    return;
                }

                // Weighted random selection
                const totalWeight = strategies.reduce((sum, s) => sum + s.weight, 0);
                let random = Math.random() * totalWeight;

                for (const strat of strategies) {
                    random -= strat.weight;
                    if (random <= 0) {
                        this.currentStrategy = strat.strategy();
                        const minMoves = this.difficulty === 'hard' ? 8 : 5;
                        const maxMoves = this.difficulty === 'hard' ? 15 : 10;
                        this.strategyTimer = Math.floor(Math.random() * (maxMoves - minMoves + 1)) + minMoves;
                        return;
                    }
                }

                // Fallback
                this.currentStrategy = new AggressiveHunter(this.aiCycle, this.difficulty);
            }

            getStrategyWeights() {
                const spatialGrid = getGlobalSpatialGrid();
                const aiSpace = floodFill(this.aiCycle.x, this.aiCycle.y, spatialGrid, 200);
                const totalSpace = (canvas.width / GRID_SIZE) * (canvas.height / GRID_SIZE);
                const spaceRatio = aiSpace / Math.max(totalSpace * 0.3, 1);

                let weights = {
                    aggressive: 1.0,
                    territory: 1.0,
                    mirror: 1.0,
                    chaotic: 1.0,
                    adaptive: 1.0,
                    trapper: 1.0
                };

                // Difficulty-based base weights
                if (this.difficulty === 'easy') {
                    weights.chaotic = 3.0;
                    weights.territory = 1.5;
                    weights.aggressive = 0.5;
                    weights.adaptive = 0.3;
                    weights.mirror = 0.8;
                    weights.trapper = 0.0; // No trapper on easy
                } else if (this.difficulty === 'medium') {
                    // Balanced - all equal base weights
                    weights.trapper = 0.0; // No trapper on medium
                } else { // hard
                    weights.adaptive = 5.0;
                    weights.aggressive = 4.0;
                    weights.territory = 2.0;
                    weights.chaotic = 0.05;
                    weights.mirror = 0.5;
                    weights.trapper = 6.0; // Highest priority - actively traps player
                }

                // Situational adjustments
                if (spaceRatio < 0.3) {
                    weights.aggressive *= 2.0;
                    weights.chaotic *= 1.5;
                } else if (spaceRatio > 0.6) {
                    weights.territory *= 2.0;
                }

                // Reduce current strategy weight to encourage variety
                if (this.currentStrategy) {
                    const currentName = this.currentStrategy.constructor.name.toLowerCase();
                    if (currentName.includes('aggressive')) weights.aggressive *= 0.3;
                    else if (currentName.includes('territory')) weights.territory *= 0.3;
                    else if (currentName.includes('mirror')) weights.mirror *= 0.3;
                    else if (currentName.includes('chaotic')) weights.chaotic *= 0.3;
                    else if (currentName.includes('adaptive')) weights.adaptive *= 0.3;
                    else if (currentName.includes('trapper')) weights.trapper *= 0.3;
                }

                return weights;
            }

            maybeSwitchStrategy() {
                this.strategyTimer--;

                if (this.strategyTimer <= 0) {
                    // Hard mode: Keep strategies longer for consistency
                    const switchChance = this.difficulty === 'hard' ? 0.15 : 0.3;

                    if (Math.random() < switchChance) {
                        this.selectNewStrategy();
                    } else {
                        // Hard mode: Longer strategy duration
                        const minMoves = this.difficulty === 'hard' ? 8 : 5;
                        const maxMoves = this.difficulty === 'hard' ? 15 : 11;
                        this.strategyTimer = Math.floor(Math.random() * (maxMoves - minMoves + 1)) + minMoves;
                    }
                }
            }

            trackPlayer(player) {
                if (!player || !player.alive) return;

                if (this.lastPlayerPos) {
                    const dx = player.x - this.lastPlayerPos.x;
                    const dy = player.y - this.lastPlayerPos.y;

                    if (dx !== 0 || dy !== 0) {
                        this.playerMovementHistory.push({ x: dx, y: dy, time: Date.now() });

                        if (this.playerMovementHistory.length > 20) {
                            this.playerMovementHistory.shift();
                        }

                        // Detect direction changes
                        if (this.playerMovementHistory.length >= 2) {
                            const prev = this.playerMovementHistory[this.playerMovementHistory.length - 2];
                            if (prev.x !== dx || prev.y !== dy) {
                                this.playerTurnCount++;
                            }
                        }
                    }
                }

                this.lastPlayerPos = { x: player.x, y: player.y };
            }

            decideMove(player, allCycles) {
                // Lazy initialization on first move
                if (!this.initialized) {
                    this.selectNewStrategy();
                    this.initialized = true;
                }

                this.moveCount++;
                this.trackPlayer(player);
                this.maybeSwitchStrategy();

                if (!this.currentStrategy) {
                    this.selectNewStrategy();
                }

                return this.currentStrategy.evaluate(player, allCycles);
            }
        }

        // Base strategy class
        class AIStrategy {
            constructor(aiCycle, difficulty = 'medium') {
                this.aiCycle = aiCycle;
                this.difficulty = difficulty;
            }

            getPossibleDirections() {
                return [DIR.UP, DIR.DOWN, DIR.LEFT, DIR.RIGHT].filter(dir => {
                    // Filter out 180-degree turns
                    if (this.aiCycle.direction.x + dir.x === 0 &&
                        this.aiCycle.direction.y + dir.y === 0) {
                        return false;
                    }
                    return true;
                });
            }

            evaluateSpace(dir) {
                const testX = this.aiCycle.x + dir.x * GRID_SIZE;
                const testY = this.aiCycle.y + dir.y * GRID_SIZE;
                const spatialGrid = getGlobalSpatialGrid();

                if (spatialGrid.isOccupied(testX, testY)) {
                    return { direction: dir, space: -1, x: testX, y: testY };
                }

                const space = floodFill(testX, testY, spatialGrid, 200);
                return { direction: dir, space, x: testX, y: testY };
            }

            applyNoise(evaluations, noiseFactor = 0.2) {
                // Reduce noise significantly for hard difficulty
                if (this.difficulty === 'hard') {
                    noiseFactor *= 0.2; // 80% reduction in randomness for hard mode
                }

                return evaluations.map(evaluation => ({
                    ...evaluation,
                    space: evaluation.space * (1 - noiseFactor + Math.random() * noiseFactor * 2)
                }));
            }
        }

        // Strategy 1: Aggressive Hunter
        class AggressiveHunter extends AIStrategy {
            evaluate(player, allCycles) {
                const directions = this.getPossibleDirections();
                let evaluations = directions.map(dir => this.evaluateSpace(dir));

                // Remove invalid moves
                evaluations = evaluations.filter(e => e.space >= 0);
                if (evaluations.length === 0) return null;

                // Add aggression toward player
                if (player && player.alive) {
                    evaluations.forEach(evaluation => {
                        const distToPlayer = Math.sqrt(
                            Math.pow(evaluation.x - player.x, 2) + Math.pow(evaluation.y - player.y, 2)
                        );

                        // Hard mode: Much more aggressive
                        if (this.difficulty === 'hard') {
                            // Always hunt the player, even from far away
                            const aggressionBonus = Math.max(0, 500 - distToPlayer) * 1.2;
                            evaluation.space = evaluation.space * 0.15 + aggressionBonus;
                        } else {
                            // Normal aggression for other difficulties
                            const aggressionBonus = Math.max(0, 100 - distToPlayer) * 0.7;
                            evaluation.space = evaluation.space * 0.3 + aggressionBonus;
                        }
                    });
                }

                // Apply noise
                evaluations = this.applyNoise(evaluations, 0.15);

                // Sort and pick best
                evaluations.sort((a, b) => b.space - a.space);
                return evaluations[0].direction;
            }
        }

        // Strategy 2: Territory Controller
        class TerritoryController extends AIStrategy {
            constructor(aiCycle, difficulty) {
                super(aiCycle, difficulty);
                this.territoryCenter = null; // Lazy init
            }

            selectTerritory(player = null) {
                // Pick a quadrant to claim - lazy init to avoid canvas reference before it exists
                const canvasEl = document.getElementById('gameCanvas');
                if (!canvasEl) return { x: 200, y: 200 }; // Fallback

                // Hard mode: Pick territory that blocks player
                if (this.difficulty === 'hard' && player && player.alive) {
                    // Choose point between AI and player to cut them off
                    const midX = (this.aiCycle.x + player.x) / 2;
                    const midY = (this.aiCycle.y + player.y) / 2;
                    return { x: midX, y: midY };
                }

                // Normal mode: Random quadrant
                const quadrants = [
                    { x: canvasEl.width * 0.25, y: canvasEl.height * 0.25 },
                    { x: canvasEl.width * 0.75, y: canvasEl.height * 0.25 },
                    { x: canvasEl.width * 0.25, y: canvasEl.height * 0.75 },
                    { x: canvasEl.width * 0.75, y: canvasEl.height * 0.75 }
                ];
                return quadrants[Math.floor(Math.random() * quadrants.length)];
            }

            evaluate(player, allCycles) {
                // Lazy init territory center
                if (!this.territoryCenter) {
                    this.territoryCenter = this.selectTerritory(player);
                }

                const directions = this.getPossibleDirections();
                let evaluations = directions.map(dir => this.evaluateSpace(dir));

                evaluations = evaluations.filter(e => e.space >= 0);
                if (evaluations.length === 0) return null;

                // Prioritize staying in territory
                evaluations.forEach(evaluation => {
                    const distToTerritory = Math.sqrt(
                        Math.pow(evaluation.x - this.territoryCenter.x, 2) +
                        Math.pow(evaluation.y - this.territoryCenter.y, 2)
                    );

                    // Bonus for staying near territory center
                    const territoryBonus = Math.max(0, 200 - distToTerritory) * 0.5;
                    evaluation.space += territoryBonus;
                });

                evaluations = this.applyNoise(evaluations, 0.18);
                evaluations.sort((a, b) => b.space - a.space);

                // Maybe relocate territory if current area is getting crowded
                const currentDist = Math.sqrt(
                    Math.pow(this.aiCycle.x - this.territoryCenter.x, 2) +
                    Math.pow(this.aiCycle.y - this.territoryCenter.y, 2)
                );

                // Hard mode: Relocate more frequently to stay between AI and player
                const relocateThreshold = this.difficulty === 'hard' ? 100 : 250;
                if (currentDist > relocateThreshold) {
                    this.territoryCenter = this.selectTerritory(player);
                }

                return evaluations[0].direction;
            }
        }

        // Strategy 3: Mirror Player
        class MirrorPlayer extends AIStrategy {
            evaluate(player, allCycles) {
                const directions = this.getPossibleDirections();
                let evaluations = directions.map(dir => this.evaluateSpace(dir));

                evaluations = evaluations.filter(e => e.space >= 0);
                if (evaluations.length === 0) return null;

                if (player && player.alive) {
                    // Try to parallel player's path
                    const playerDir = player.direction;

                    evaluations.forEach(evaluation => {
                        // Bonus for moving in same direction as player
                        if (evaluation.direction.x === playerDir.x && evaluation.direction.y === playerDir.y) {
                            evaluation.space += 50;
                        }

                        // Bonus for staying parallel (3-5 grid units away)
                        const distToPlayer = Math.sqrt(
                            Math.pow(evaluation.x - player.x, 2) + Math.pow(evaluation.y - player.y, 2)
                        );

                        const idealDist = GRID_SIZE * 4;
                        const distScore = Math.max(0, 100 - Math.abs(distToPlayer - idealDist));
                        evaluation.space += distScore * 0.4;
                    });
                }

                // Safety override if space too low
                const maxSpace = Math.max(...evaluations.map(e => e.space));
                if (maxSpace < 30) {
                    evaluations.sort((a, b) => b.space - a.space);
                    return evaluations[0].direction;
                }

                evaluations = this.applyNoise(evaluations, 0.25);
                evaluations.sort((a, b) => b.space - a.space);
                return evaluations[0].direction;
            }
        }

        // Strategy 4: Chaotic Jester
        class ChaoticJester extends AIStrategy {
            evaluate(player, allCycles) {
                const directions = this.getPossibleDirections();
                let evaluations = directions.map(dir => this.evaluateSpace(dir));

                evaluations = evaluations.filter(e => e.space >= 0);
                if (evaluations.length === 0) return null;

                // 40% pure random, 60% from top candidates
                if (Math.random() < 0.4) {
                    // Pure random valid move
                    return evaluations[Math.floor(Math.random() * evaluations.length)].direction;
                } else {
                    // Pick from top 3
                    evaluations.sort((a, b) => b.space - a.space);
                    const topChoices = evaluations.slice(0, Math.min(3, evaluations.length));
                    return topChoices[Math.floor(Math.random() * topChoices.length)].direction;
                }
            }
        }

        // Strategy 5: Adaptive Learner
        class AdaptiveLearner extends AIStrategy {
            evaluate(player, allCycles) {
                const directions = this.getPossibleDirections();
                let evaluations = directions.map(dir => this.evaluateSpace(dir));

                evaluations = evaluations.filter(e => e.space >= 0);
                if (evaluations.length === 0) return null;

                if (player && player.alive) {
                    // Hard mode: Predict further ahead
                    const predictionSteps = this.difficulty === 'hard' ? 6 : 3;
                    const predictedX = player.x + player.direction.x * GRID_SIZE * predictionSteps;
                    const predictedY = player.y + player.direction.y * GRID_SIZE * predictionSteps;

                    evaluations.forEach(evaluation => {
                        // Try to intercept predicted position
                        const distToPredicted = Math.sqrt(
                            Math.pow(evaluation.x - predictedX, 2) + Math.pow(evaluation.y - predictedY, 2)
                        );

                        if (this.difficulty === 'hard') {
                            // More aggressive interception on hard
                            const interceptBonus = Math.max(0, 300 - distToPredicted) * 1.0;
                            evaluation.space = evaluation.space * 0.2 + interceptBonus;
                        } else {
                            const interceptBonus = Math.max(0, 120 - distToPredicted) * 0.6;
                            evaluation.space += interceptBonus;
                        }
                    });
                }

                evaluations = this.applyNoise(evaluations, 0.1); // Low noise for "smart" strategy
                evaluations.sort((a, b) => b.space - a.space);

                // Hard mode: Always pick best
                if (this.difficulty === 'hard') {
                    return evaluations[0].direction;
                }

                // Other difficulties: 90% pick best, 10% pick 2nd best for unpredictability
                if (evaluations.length > 1 && Math.random() < 0.1) {
                    return evaluations[1].direction;
                }

                return evaluations[0].direction;
            }
        }

        // Strategy 6: Trapper - Actively reduces player's available space
        class TrapperStrategy extends AIStrategy {
            evaluate(player, allCycles) {
                const directions = this.getPossibleDirections();
                let evaluations = directions.map(dir => this.evaluateSpace(dir));

                evaluations = evaluations.filter(e => e.space >= 0);
                if (evaluations.length === 0) return null;

                if (player && player.alive) {
                    const spatialGrid = getGlobalSpatialGrid();

                    // Calculate player's current available space
                    const playerSpace = floodFill(player.x, player.y, spatialGrid, 200);

                    evaluations.forEach(evaluation => {
                        // Simulate this move and recalculate player space
                        const simGrid = new SpatialGrid(canvas.width, canvas.height, GRID_SIZE);

                        // Copy existing trails
                        for (const cycle of lightCycles) {
                            for (const segment of cycle.trail) {
                                simGrid.markOccupied(segment.x, segment.y);
                            }
                        }

                        // Add simulated AI position
                        simGrid.markOccupied(evaluation.x, evaluation.y);

                        // Calculate player's space after this move
                        const newPlayerSpace = floodFill(player.x, player.y, simGrid, 200);

                        // Bonus for reducing player's space
                        const spaceReduction = playerSpace - newPlayerSpace;
                        const trapBonus = spaceReduction * 2.5;

                        // Also bonus for getting between player and open space
                        const distToPlayer = Math.sqrt(
                            Math.pow(evaluation.x - player.x, 2) + Math.pow(evaluation.y - player.y, 2)
                        );

                        // Optimal trapping distance is 3-6 grid units
                        const optimalDist = GRID_SIZE * 4.5;
                        const distanceScore = Math.max(0, 100 - Math.abs(distToPlayer - optimalDist)) * 0.4;

                        // Combine space safety, trap bonus, and positioning
                        evaluation.space = evaluation.space * 0.3 + trapBonus + distanceScore;
                    });
                }

                // Very low noise for trapping strategy (needs precision)
                evaluations = this.applyNoise(evaluations, 0.08);
                evaluations.sort((a, b) => b.space - a.space);
                return evaluations[0].direction;
            }
        }

        // ==================== END NEW AI BRAIN SYSTEM ====================

        // Game objects
        let lightCycles = [];
        let player;

        // Initialize game
        function initGame() {
            lightCycles = [];
            score = 0;
            gameSpeed = INITIAL_SPEED;
            survivedTime = 0;

            // Create player
            player = new LightCycle(
                canvas.width / 2,
                canvas.height / 2,
                DIR.RIGHT,
                '#00D9FF',
                true
            );
            lightCycles.push(player);

            // Create AI opponents
            const positions = [
                { x: canvas.width * 0.2, y: canvas.height * 0.2, dir: DIR.DOWN },
                { x: canvas.width * 0.8, y: canvas.height * 0.2, dir: DIR.LEFT },
                { x: canvas.width * 0.5, y: canvas.height * 0.8, dir: DIR.UP }
            ];

            for (let i = 0; i < Math.min(AI_COUNT, positions.length); i++) {
                const pos = positions[i];
                const ai = new AICycle(pos.x, pos.y, pos.dir, '#FF0000', difficulty);
                lightCycles.push(ai);
            }

            updateHUD();
        }

        // Game loop
        function gameLoop(timestamp) {
            if (!gameRunning) return;

            const deltaTime = timestamp - lastUpdateTime;

            if (deltaTime >= gameSpeed) {
                lastUpdateTime = timestamp;
                frameCount++;

                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw grid
                drawGrid();

                // Update AI decisions
                for (const cycle of lightCycles) {
                    if (cycle instanceof AICycle) {
                        cycle.updateAI();
                    }
                }

                // Phase 1: Move all cycles simultaneously
                for (const cycle of lightCycles) {
                    cycle.update();
                }

                // Phase 2: Check collisions after ALL cycles have moved
                for (const cycle of lightCycles) {
                    cycle.checkCollisionsPhase();
                }

                // Draw all cycles
                for (const cycle of lightCycles) {
                    cycle.draw();
                }

                // Update score
                if (player.alive) {
                    score += 10;
                    survivedTime += deltaTime;

                    // Increase speed over time
                    if (gameSpeed > 50) {
                        gameSpeed -= SPEED_INCREASE;
                    }
                }

                updateHUD();

                // Count alive cycles
                const aliveCycles = lightCycles.filter(c => c.alive);
                const aliveCount = aliveCycles.length;
                const aliveAI = lightCycles.filter(c => !c.isPlayer && c.alive).length;

                debugLog(`Frame ${frameCount}: ${aliveCount} cycles alive (Player: ${player.alive ? 'YES' : 'NO'}, AI: ${aliveAI})`);

                // Check game over
                if (!player.alive) {
                    debugLog(`Game Over: Player died. Total alive: ${aliveCount}`);
                    endGame();
                    return;
                }

                // Check if all AI are dead (player wins this round)
                if (aliveAI === 0) {
                    score += 1000;
                    playSound('victory');
                    debugLog('Victory: All AI defeated!');
                    // Could add new AI here for endless mode
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // Draw grid
        function drawGrid() {
            ctx.strokeStyle = 'rgba(0, 217, 255, 0.1)';
            ctx.lineWidth = 1;

            for (let x = 0; x < canvas.width; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            for (let y = 0; y < canvas.height; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // Update HUD
        function updateHUD() {
            document.getElementById('score').textContent = score;
            document.getElementById('highScore').textContent = highScore;
            document.getElementById('speed').textContent = (INITIAL_SPEED / gameSpeed).toFixed(1) + 'x';
        }

        // Start game
        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            difficulty = document.getElementById('difficultySelect').value;
            gameRunning = true;
            initGame();
            lastUpdateTime = performance.now();
            requestAnimationFrame(gameLoop);
            playSound('start');
        }

        // End game
        function endGame() {
            gameRunning = false;

            // Update high score
            if (score > highScore) {
                highScore = score;
                safeSetItem('tronLightCycleHighScore', highScore.toString());
            }

            // Show game over screen
            const statsDiv = document.getElementById('gameOverStats');
            statsDiv.innerHTML = `
                <div class="stat-line">
                    <span class="stat-label">FINAL SCORE:</span>
                    <span class="stat-value">${score}</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">HIGH SCORE:</span>
                    <span class="stat-value">${highScore}</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">SURVIVED:</span>
                    <span class="stat-value">${(survivedTime / 1000).toFixed(1)}s</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">MAX SPEED:</span>
                    <span class="stat-value">${(INITIAL_SPEED / gameSpeed).toFixed(1)}x</span>
                </div>
            `;

            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        // Sound effects
        function playSound(type) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            switch(type) {
                case 'start':
                    oscillator.frequency.value = 400;
                    gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.3);
                    break;
                case 'crash':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.3);
                    break;
                case 'victory':
                    oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.4);
                    break;
            }
        }

        // Controls
        const keydownHandler = (e) => {
            if (!gameRunning || !player.alive) return;

            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    player.changeDirection(DIR.UP);
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    player.changeDirection(DIR.DOWN);
                    e.preventDefault();
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    player.changeDirection(DIR.LEFT);
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    player.changeDirection(DIR.RIGHT);
                    e.preventDefault();
                    break;
            }
        };
        eventManager.add(document, 'keydown', keydownHandler);

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;

        const touchstartHandler = (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault();
        };

        const touchmoveHandler = (e) => {
            if (!gameRunning || !player.alive) return;

            const touchEndX = e.touches[0].clientX;
            const touchEndY = e.touches[0].clientY;

            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (deltaX > 20) {
                    player.changeDirection(DIR.RIGHT);
                    touchStartX = touchEndX;
                } else if (deltaX < -20) {
                    player.changeDirection(DIR.LEFT);
                    touchStartX = touchEndX;
                }
            } else {
                // Vertical swipe
                if (deltaY > 20) {
                    player.changeDirection(DIR.DOWN);
                    touchStartY = touchEndY;
                } else if (deltaY < -20) {
                    player.changeDirection(DIR.UP);
                    touchStartY = touchEndY;
                }
            }

            e.preventDefault();
        };

        eventManager.add(canvas, 'touchstart', touchstartHandler, { passive: false });
        eventManager.add(canvas, 'touchmove', touchmoveHandler, { passive: false });

        // Button events
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', () => {
            document.getElementById('gameOverScreen').classList.add('hidden');
            startGame();
        });
        document.getElementById('menuBtn').addEventListener('click', () => {
            window.location.href = '../../tron-index.html';
        });

        // Initialize
        updateHUD();
    </script>
</body>
</html>
