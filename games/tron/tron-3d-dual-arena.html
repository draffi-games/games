<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tron: 3D Dual Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000810;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #gameCanvas {
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            background: #000810;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-size: 16px;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            background: rgba(0, 8, 16, 0.8);
            padding: 10px 20px;
            border-radius: 5px;
            pointer-events: none;
            z-index: 100;
        }

        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffff;
            text-decoration: none;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            z-index: 100;
        }

        .back-link:hover {
            color: #ffffff;
        }
    </style>
</head>
<body>
    <a href="../../index.html" class="back-link">← Back</a>
    <canvas id="gameCanvas"></canvas>
    <div id="instructions">
        P1: A/D + W to Jump | P2: ← → + ↑ to Jump | Or connect gamepads!
    </div>

    <script>
        // ===== CONSTANTS =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = 1600;
        canvas.height = 900;

        const GRID_SIZE = 80; // 80x80 arena
        const MOVE_SPEED = 0.15; // grid units per frame
        const TURN_COOLDOWN = 150; // ms between turns
        const JUMP_VELOCITY = 0.35;
        const GRAVITY = 0.02;
        const JUMP_HEIGHT_THRESHOLD = 0.8; // must be this high to clear trails
        const JUMP_COOLDOWN_FRAMES = 90; // ~1.5 seconds at 60fps
        const WALL_HEIGHT = 2.0; // trail wall height
        const MAX_TRAIL_SEGMENTS = 1500; // per player

        const COLORS = {
            PLAYER1: '#00ffff',
            PLAYER2: '#ff6600',
            GRID: '#003366',
            BACKGROUND: '#000810',
            TEXT: '#00ffff'
        };

        const DIRECTIONS = {
            UP: { x: 0, y: -1, angle: -Math.PI / 2 },
            DOWN: { x: 0, y: 1, angle: Math.PI / 2 },
            LEFT: { x: -1, y: 0, angle: Math.PI },
            RIGHT: { x: 1, y: 0, angle: 0 }
        };

        // ===== GAME STATE =====
        let gameState = 'WAITING'; // WAITING, COUNTDOWN, PLAYING, ROUND_OVER, MATCH_OVER
        let countdownTimer = 0;
        let roundWinner = null;
        let scores = { player1: 0, player2: 0 };
        let currentRound = 1;
        const keysPressed = new Set();
        const collisionGrid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));

        // ===== 3D MATH UTILITIES =====
        function project3D(worldPos, camera, viewport) {
            // Translate to camera space
            let dx = worldPos.x - camera.x;
            let dy = worldPos.y - camera.y;
            let dz = worldPos.z - camera.z;

            // Rotate by camera yaw (horizontal rotation)
            const cosYaw = Math.cos(camera.yaw);
            const sinYaw = Math.sin(camera.yaw);
            let rotX = dx * cosYaw - dy * sinYaw;
            let rotY = dx * sinYaw + dy * cosYaw;
            let rotZ = dz;

            // Rotate by camera pitch (vertical rotation) - look down at track
            const cosPitch = Math.cos(camera.pitch);
            const sinPitch = Math.sin(camera.pitch);
            const finalY = rotY * cosPitch - rotZ * sinPitch;
            const finalZ = rotY * sinPitch + rotZ * cosPitch;

            // Behind camera check
            if (finalY <= 0.1) return null;

            // Perspective projection with wider FOV for better spatial awareness
            const fov = 95 * Math.PI / 180;
            const focalLength = viewport.h / (2 * Math.tan(fov / 2));

            const screenX = (rotX * focalLength / finalY) + viewport.centerX;
            const screenY = (-finalZ * focalLength / finalY) + viewport.centerY;

            return { x: screenX, y: screenY, depth: finalY };
        }

        function createCamera(player) {
            const camDistance = 6;        // Behind player
            const camHeight = 3.5;         // Just above trails for centered view
            const lookAhead = 5;           // Look ahead of player

            const dirX = Math.cos(player.angle);
            const dirY = Math.sin(player.angle);

            // Camera position: behind and above player
            const camX = player.x - dirX * camDistance;
            const camY = player.y - dirY * camDistance;

            // Very gentle pitch for horizontal racing view
            // -0.1 radians ≈ -6 degrees - ground/trails centered
            const pitch = -0.1;

            return {
                x: camX,
                y: camY,
                z: camHeight,
                yaw: player.angle,
                pitch: pitch
            };
        }

        // ===== PLAYER CLASS =====
        class Player {
            constructor(id, startX, startY, direction, color) {
                this.id = id;
                this.startX = startX;
                this.startY = startY;
                this.startDir = direction;
                this.color = color;
                this.reset();
            }

            reset() {
                this.x = this.startX;
                this.y = this.startY;
                this.direction = this.startDir;
                this.angle = this.direction.angle;
                this.alive = true;
                this.z = 0;
                this.vz = 0;
                this.isJumping = false;
                this.jumpCooldown = 0;
                this.lastTurn = 0;
                this.jumpKeyHeld = false;
                this.trail = [];
                this.prevX = this.x;
                this.prevY = this.y;
            }

            turnLeft() {
                const dirs = [DIRECTIONS.UP, DIRECTIONS.LEFT, DIRECTIONS.DOWN, DIRECTIONS.RIGHT];
                let currentIndex = -1;
                for (let i = 0; i < dirs.length; i++) {
                    if (dirs[i] === this.direction) {
                        currentIndex = i;
                        break;
                    }
                }
                this.direction = dirs[(currentIndex + 1) % 4];
                this.angle = this.direction.angle;
            }

            turnRight() {
                const dirs = [DIRECTIONS.UP, DIRECTIONS.RIGHT, DIRECTIONS.DOWN, DIRECTIONS.LEFT];
                let currentIndex = -1;
                for (let i = 0; i < dirs.length; i++) {
                    if (dirs[i] === this.direction) {
                        currentIndex = i;
                        break;
                    }
                }
                this.direction = dirs[(currentIndex + 1) % 4];
                this.angle = this.direction.angle;
            }

            jump() {
                if (this.jumpCooldown <= 0 && !this.isJumping && this.z <= 0) {
                    this.isJumping = true;
                    this.vz = JUMP_VELOCITY;
                    this.jumpCooldown = JUMP_COOLDOWN_FRAMES;
                }
            }

            update() {
                if (!this.alive || gameState !== 'PLAYING') return;

                // Save previous position
                this.prevX = this.x;
                this.prevY = this.y;

                // Move forward
                this.x += this.direction.x * MOVE_SPEED;
                this.y += this.direction.y * MOVE_SPEED;

                // Update jump physics
                if (this.isJumping) {
                    this.z += this.vz;
                    this.vz -= GRAVITY;

                    if (this.z <= 0) {
                        this.z = 0;
                        this.vz = 0;
                        this.isJumping = false;
                    }
                }

                if (this.jumpCooldown > 0) this.jumpCooldown--;

                // Check collision BEFORE writing to grid to avoid self-collision
                this.checkCollision();

                // Add trail segment
                const distMoved = Math.sqrt((this.x - this.prevX) ** 2 + (this.y - this.prevY) ** 2);
                if (distMoved > 0.1) {
                    this.trail.push({
                        x1: this.prevX,
                        y1: this.prevY,
                        x2: this.x,
                        y2: this.y,
                        color: this.color
                    });

                    // Limit trail length
                    if (this.trail.length > MAX_TRAIL_SEGMENTS) {
                        this.trail.shift();
                    }
                }

                // Update collision grid (only if not jumping high enough and still alive)
                if (this.alive && this.z <= JUMP_HEIGHT_THRESHOLD) {
                    const gridX = Math.floor(this.x);
                    const gridY = Math.floor(this.y);
                    if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
                        collisionGrid[gridY][gridX] = this.id === 'player1' ? 1 : 2;
                    }
                }
            }

            checkCollision() {
                const gridX = Math.floor(this.x);
                const gridY = Math.floor(this.y);

                // Out of bounds
                if (gridX < 0 || gridX >= GRID_SIZE || gridY < 0 || gridY >= GRID_SIZE) {
                    this.alive = false;
                    return;
                }

                // Check collision with trails
                const cell = collisionGrid[gridY][gridX];
                const myCell = this.id === 'player1' ? 1 : 2;

                // Only collide with opponent's trail (or walls), not your own
                if (cell !== 0 && cell !== myCell) {
                    // If jumping high enough, clear the obstacle
                    if (this.z > JUMP_HEIGHT_THRESHOLD) {
                        return; // jumped over it!
                    }
                    this.alive = false;
                }
            }
        }

        // ===== PLAYERS =====
        const player1 = new Player('player1', 20, 40, DIRECTIONS.RIGHT, COLORS.PLAYER1);
        const player2 = new Player('player2', 60, 40, DIRECTIONS.LEFT, COLORS.PLAYER2);

        // ===== INPUT HANDLING =====
        window.addEventListener('keydown', (e) => {
            keysPressed.add(e.key.toLowerCase());
            if (gameState === 'WAITING') {
                startGame();
            }
        });

        window.addEventListener('keyup', (e) => {
            keysPressed.delete(e.key.toLowerCase());
        });

        function handleKeyboardInput(player, keySet) {
            const now = Date.now();

            if (keySet === 'WASD') {
                if (keysPressed.has('a') && now - player.lastTurn > TURN_COOLDOWN) {
                    player.turnLeft();
                    player.lastTurn = now;
                }
                if (keysPressed.has('d') && now - player.lastTurn > TURN_COOLDOWN) {
                    player.turnRight();
                    player.lastTurn = now;
                }
                if (keysPressed.has('w') && !player.jumpKeyHeld) {
                    player.jump();
                    player.jumpKeyHeld = true;
                }
                if (!keysPressed.has('w')) {
                    player.jumpKeyHeld = false;
                }
            } else {
                if (keysPressed.has('arrowleft') && now - player.lastTurn > TURN_COOLDOWN) {
                    player.turnLeft();
                    player.lastTurn = now;
                }
                if (keysPressed.has('arrowright') && now - player.lastTurn > TURN_COOLDOWN) {
                    player.turnRight();
                    player.lastTurn = now;
                }
                if (keysPressed.has('arrowup') && !player.jumpKeyHeld) {
                    player.jump();
                    player.jumpKeyHeld = true;
                }
                if (!keysPressed.has('arrowup')) {
                    player.jumpKeyHeld = false;
                }
            }
        }

        function handleGamepadInput(player, gamepad) {
            const DEADZONE = 0.3;
            const now = Date.now();

            let horizontal = gamepad.axes[0];
            if (Math.abs(horizontal) < DEADZONE) horizontal = 0;

            // D-pad override
            if (gamepad.buttons[14] && gamepad.buttons[14].pressed) horizontal = -1;
            if (gamepad.buttons[15] && gamepad.buttons[15].pressed) horizontal = 1;

            // Turn
            if (horizontal < -0.5 && now - player.lastTurn > TURN_COOLDOWN) {
                player.turnLeft();
                player.lastTurn = now;
            } else if (horizontal > 0.5 && now - player.lastTurn > TURN_COOLDOWN) {
                player.turnRight();
                player.lastTurn = now;
            }

            // Jump (A or B button)
            const jumpPressed = (gamepad.buttons[0] && gamepad.buttons[0].pressed) ||
                              (gamepad.buttons[1] && gamepad.buttons[1].pressed);

            if (jumpPressed && !player.jumpKeyHeld) {
                player.jump();
                player.jumpKeyHeld = true;
            }
            if (!jumpPressed) {
                player.jumpKeyHeld = false;
            }
        }

        function updateInput() {
            if (gameState !== 'PLAYING') return;

            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];

            // Player 1
            if (gamepads[0]) {
                handleGamepadInput(player1, gamepads[0]);
            } else {
                handleKeyboardInput(player1, 'WASD');
            }

            // Player 2
            if (gamepads[1]) {
                handleGamepadInput(player2, gamepads[1]);
            } else {
                handleKeyboardInput(player2, 'ARROWS');
            }
        }

        // ===== RENDERING =====
        function renderFloor(ctx, camera, viewport) {
            const gridSpacing = 5;
            const renderDistance = 40;

            ctx.lineWidth = 1;

            // Draw grid lines
            for (let i = 0; i <= GRID_SIZE; i += gridSpacing) {
                // Lines along Y axis
                const p1 = project3D({ x: i, y: 0, z: 0 }, camera, viewport);
                const p2 = project3D({ x: i, y: GRID_SIZE, z: 0 }, camera, viewport);

                if (p1 && p2) {
                    const dist = Math.sqrt((i - camera.x) ** 2 + camera.y ** 2);
                    const alpha = Math.max(0, Math.min(1, 1 - dist / renderDistance));

                    ctx.strokeStyle = `rgba(0, 51, 102, ${alpha * 0.5})`;
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }

                // Lines along X axis
                const p3 = project3D({ x: 0, y: i, z: 0 }, camera, viewport);
                const p4 = project3D({ x: GRID_SIZE, y: i, z: 0 }, camera, viewport);

                if (p3 && p4) {
                    const dist = Math.sqrt(camera.x ** 2 + (i - camera.y) ** 2);
                    const alpha = Math.max(0, Math.min(1, 1 - dist / renderDistance));

                    ctx.strokeStyle = `rgba(0, 51, 102, ${alpha * 0.5})`;
                    ctx.beginPath();
                    ctx.moveTo(p3.x, p3.y);
                    ctx.lineTo(p4.x, p4.y);
                    ctx.stroke();
                }
            }
        }

        function renderTrailSegment(ctx, segment, camera, viewport) {
            const corners = [
                { x: segment.x1, y: segment.y1, z: 0 },
                { x: segment.x2, y: segment.y2, z: 0 },
                { x: segment.x2, y: segment.y2, z: WALL_HEIGHT },
                { x: segment.x1, y: segment.y1, z: WALL_HEIGHT }
            ];

            const projected = corners.map(c => project3D(c, camera, viewport)).filter(p => p !== null);

            if (projected.length === 4) {
                ctx.fillStyle = segment.color;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.moveTo(projected[0].x, projected[0].y);
                for (let i = 1; i < 4; i++) {
                    ctx.lineTo(projected[i].x, projected[i].y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1.0;

                // Glow outline
                ctx.strokeStyle = segment.color;
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = segment.color;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        }

        function renderTrails3D(ctx, camera, viewport, trails) {
            // Collect and sort by depth
            const segmentsWithDepth = [];

            for (const segment of trails) {
                const midX = (segment.x1 + segment.x2) / 2;
                const midY = (segment.y1 + segment.y2) / 2;
                const dx = midX - camera.x;
                const dy = midY - camera.y;

                // Basic frustum culling
                const cosYaw = Math.cos(camera.yaw);
                const sinYaw = Math.sin(camera.yaw);
                const rotY = dx * sinYaw + dy * cosYaw;

                if (rotY > 0) {
                    segmentsWithDepth.push({ segment, depth: rotY });
                }
            }

            // Sort far to near (use camera-space depth, not Euclidean distance)
            segmentsWithDepth.sort((a, b) => b.depth - a.depth);

            // Render
            for (const item of segmentsWithDepth) {
                renderTrailSegment(ctx, item.segment, camera, viewport);
            }
        }

        function renderCycle(ctx, player, camera, viewport) {
            const cycleSize = 0.8;

            // Simple representation: glowing cube
            const corners = [
                { x: player.x - cycleSize / 2, y: player.y - cycleSize / 2, z: player.z },
                { x: player.x + cycleSize / 2, y: player.y - cycleSize / 2, z: player.z },
                { x: player.x + cycleSize / 2, y: player.y + cycleSize / 2, z: player.z },
                { x: player.x - cycleSize / 2, y: player.y + cycleSize / 2, z: player.z },
                { x: player.x - cycleSize / 2, y: player.y - cycleSize / 2, z: player.z + 1 },
                { x: player.x + cycleSize / 2, y: player.y - cycleSize / 2, z: player.z + 1 },
                { x: player.x + cycleSize / 2, y: player.y + cycleSize / 2, z: player.z + 1 },
                { x: player.x - cycleSize / 2, y: player.y + cycleSize / 2, z: player.z + 1 }
            ];

            const projected = corners.map(c => project3D(c, camera, viewport));

            if (projected.every(p => p !== null)) {
                // Draw as glowing shape
                ctx.fillStyle = player.color;
                ctx.shadowBlur = 20;
                ctx.shadowColor = player.color;

                // Front face
                ctx.beginPath();
                ctx.moveTo(projected[0].x, projected[0].y);
                ctx.lineTo(projected[1].x, projected[1].y);
                ctx.lineTo(projected[2].x, projected[2].y);
                ctx.lineTo(projected[3].x, projected[3].y);
                ctx.closePath();
                ctx.fill();

                // Top face
                ctx.beginPath();
                ctx.moveTo(projected[4].x, projected[4].y);
                ctx.lineTo(projected[5].x, projected[5].y);
                ctx.lineTo(projected[6].x, projected[6].y);
                ctx.lineTo(projected[7].x, projected[7].y);
                ctx.closePath();
                ctx.fill();

                ctx.shadowBlur = 0;
            }
        }

        function renderPlayerView(ctx, player, viewport) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(viewport.x, viewport.y, viewport.w, viewport.h);
            ctx.clip();

            // Background
            ctx.fillStyle = COLORS.BACKGROUND;
            ctx.fillRect(viewport.x, viewport.y, viewport.w, viewport.h);

            if (!player.alive) {
                ctx.restore();
                return;
            }

            const camera = createCamera(player);

            // Render scene
            renderFloor(ctx, camera, viewport);

            const allTrails = [...player1.trail, ...player2.trail];
            renderTrails3D(ctx, camera, viewport, allTrails);

            // Render opponent
            const opponent = player === player1 ? player2 : player1;
            if (opponent.alive) {
                renderCycle(ctx, opponent, camera, viewport);
            }

            // Render own cycle (smaller, for reference)
            renderCycle(ctx, player, camera, viewport);

            // HUD overlay
            ctx.fillStyle = COLORS.TEXT;
            ctx.font = '20px "Courier New"';
            ctx.fillText(`Jump: ${Math.max(0, Math.ceil(player.jumpCooldown / 60))}s`, viewport.x + 10, viewport.y + 30);

            ctx.restore();

            // Border
            ctx.strokeStyle = player.color;
            ctx.lineWidth = 3;
            ctx.strokeRect(viewport.x, viewport.y, viewport.w, viewport.h);
        }

        function renderMinimap(ctx) {
            const minimapSize = 280;
            const minimapX = (canvas.width - minimapSize - 40) / 2;
            const minimapY = 10;
            const scale = minimapSize / GRID_SIZE;

            ctx.save();

            // Background
            ctx.fillStyle = 'rgba(0, 8, 16, 0.85)';
            ctx.fillRect(minimapX, minimapY, minimapSize + 40, minimapSize + 40);

            // Border
            ctx.strokeStyle = COLORS.TEXT;
            ctx.lineWidth = 2;
            ctx.strokeRect(minimapX + 20, minimapY + 20, minimapSize, minimapSize);

            ctx.translate(minimapX + 20, minimapY + 20);

            // Draw trails
            const drawMiniTrails = (trail, color) => {
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                for (const seg of trail) {
                    ctx.beginPath();
                    ctx.moveTo(seg.x1 * scale, seg.y1 * scale);
                    ctx.lineTo(seg.x2 * scale, seg.y2 * scale);
                    ctx.stroke();
                }
            };

            drawMiniTrails(player1.trail, COLORS.PLAYER1);
            drawMiniTrails(player2.trail, COLORS.PLAYER2);

            // Draw players
            const drawMiniPlayer = (player) => {
                if (!player.alive) return;
                const px = player.x * scale;
                const py = player.y * scale;

                ctx.fillStyle = player.color;
                ctx.shadowBlur = 8;
                ctx.shadowColor = player.color;
                ctx.beginPath();
                ctx.arc(px, py, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Direction indicator
                const dirLen = 12;
                ctx.strokeStyle = player.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(px + Math.cos(player.angle) * dirLen, py + Math.sin(player.angle) * dirLen);
                ctx.stroke();
            };

            drawMiniPlayer(player1);
            drawMiniPlayer(player2);

            ctx.restore();
        }

        function renderUI(ctx) {
            // Scores
            ctx.font = 'bold 32px "Courier New"';
            ctx.textAlign = 'center';

            ctx.fillStyle = COLORS.PLAYER1;
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeText(`P1: ${scores.player1}`, 200, 50);
            ctx.fillText(`P1: ${scores.player1}`, 200, 50);

            ctx.fillStyle = COLORS.PLAYER2;
            ctx.strokeText(`P2: ${scores.player2}`, canvas.width - 200, 50);
            ctx.fillText(`P2: ${scores.player2}`, canvas.width - 200, 50);

            // Round
            ctx.fillStyle = COLORS.TEXT;
            ctx.strokeText(`ROUND ${currentRound}`, canvas.width / 2, 50);
            ctx.fillText(`ROUND ${currentRound}`, canvas.width / 2, 50);

            // Game state messages
            if (gameState === 'WAITING') {
                ctx.font = 'bold 48px "Courier New"';
                ctx.fillStyle = COLORS.TEXT;
                ctx.shadowBlur = 20;
                ctx.shadowColor = COLORS.TEXT;
                ctx.strokeText('PRESS ANY KEY TO START', canvas.width / 2, canvas.height / 2);
                ctx.fillText('PRESS ANY KEY TO START', canvas.width / 2, canvas.height / 2);
                ctx.shadowBlur = 0;
            } else if (gameState === 'COUNTDOWN') {
                const countText = Math.ceil(countdownTimer / 60);
                ctx.font = 'bold 120px "Courier New"';
                ctx.fillStyle = COLORS.TEXT;
                ctx.shadowBlur = 30;
                ctx.shadowColor = COLORS.TEXT;
                if (countText > 0) {
                    ctx.strokeText(countText, canvas.width / 2, canvas.height / 2);
                    ctx.fillText(countText, canvas.width / 2, canvas.height / 2);
                } else {
                    ctx.strokeText('GO!', canvas.width / 2, canvas.height / 2);
                    ctx.fillText('GO!', canvas.width / 2, canvas.height / 2);
                }
                ctx.shadowBlur = 0;
            } else if (gameState === 'ROUND_OVER') {
                ctx.font = 'bold 64px "Courier New"';
                const winnerColor = roundWinner === 'player1' ? COLORS.PLAYER1 : COLORS.PLAYER2;
                const winnerText = roundWinner === 'player1' ? 'PLAYER 1 WINS!' : 'PLAYER 2 WINS!';
                ctx.fillStyle = winnerColor;
                ctx.shadowBlur = 30;
                ctx.shadowColor = winnerColor;
                ctx.strokeText(winnerText, canvas.width / 2, canvas.height / 2);
                ctx.fillText(winnerText, canvas.width / 2, canvas.height / 2);
                ctx.shadowBlur = 0;
            } else if (gameState === 'MATCH_OVER') {
                ctx.font = 'bold 72px "Courier New"';
                const winnerColor = scores.player1 >= 3 ? COLORS.PLAYER1 : COLORS.PLAYER2;
                const winnerText = scores.player1 >= 3 ? 'PLAYER 1 WINS MATCH!' : 'PLAYER 2 WINS MATCH!';
                ctx.fillStyle = winnerColor;
                ctx.shadowBlur = 30;
                ctx.shadowColor = winnerColor;
                ctx.strokeText(winnerText, canvas.width / 2, canvas.height / 2 - 50);
                ctx.fillText(winnerText, canvas.width / 2, canvas.height / 2 - 50);

                ctx.font = 'bold 32px "Courier New"';
                ctx.fillStyle = COLORS.TEXT;
                ctx.strokeText('PRESS ANY KEY TO RESTART', canvas.width / 2, canvas.height / 2 + 50);
                ctx.fillText('PRESS ANY KEY TO RESTART', canvas.width / 2, canvas.height / 2 + 50);
                ctx.shadowBlur = 0;
            }
        }

        function render() {
            // Clear
            ctx.fillStyle = COLORS.BACKGROUND;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Split screen viewports
            const viewport1 = {
                x: 0,
                y: 300,
                w: 800,
                h: 600,
                centerX: 400,
                centerY: 530  // Visual center shifted up for centered trail view
            };

            const viewport2 = {
                x: 800,
                y: 300,
                w: 800,
                h: 600,
                centerX: 1200,
                centerY: 530  // Visual center shifted up for centered trail view
            };

            renderPlayerView(ctx, player1, viewport1);
            renderPlayerView(ctx, player2, viewport2);
            renderMinimap(ctx);
            renderUI(ctx);
        }

        // ===== GAME LOOP =====
        function startGame() {
            if (gameState === 'MATCH_OVER') {
                // Reset match
                scores.player1 = 0;
                scores.player2 = 0;
                currentRound = 1;
            }

            gameState = 'COUNTDOWN';
            countdownTimer = 180; // 3 seconds
            resetRound();
        }

        function resetRound() {
            player1.reset();
            player2.reset();

            // Clear collision grid
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    collisionGrid[y][x] = 0;
                }
            }
        }

        function checkWinCondition() {
            if (gameState !== 'PLAYING') return;

            if (!player1.alive && player2.alive) {
                scores.player2++;
                roundWinner = 'player2';
                gameState = 'ROUND_OVER';
                setTimeout(() => {
                    if (scores.player2 >= 3) {
                        gameState = 'MATCH_OVER';
                    } else {
                        currentRound++;
                        startGame();
                    }
                }, 3000);
            } else if (!player2.alive && player1.alive) {
                scores.player1++;
                roundWinner = 'player1';
                gameState = 'ROUND_OVER';
                setTimeout(() => {
                    if (scores.player1 >= 3) {
                        gameState = 'MATCH_OVER';
                    } else {
                        currentRound++;
                        startGame();
                    }
                }, 3000);
            } else if (!player1.alive && !player2.alive) {
                // Draw - restart round
                gameState = 'ROUND_OVER';
                roundWinner = null;
                setTimeout(() => {
                    startGame();
                }, 2000);
            }
        }

        function update() {
            if (gameState === 'COUNTDOWN') {
                countdownTimer--;
                if (countdownTimer <= 0) {
                    gameState = 'PLAYING';
                }
            } else if (gameState === 'PLAYING') {
                updateInput();
                player1.update();
                player2.update();
                checkWinCondition();
            }
        }

        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Start
        gameLoop();
    </script>
</body>
</html>
